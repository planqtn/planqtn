diff --git a/DEVELOPMENT.md b/DEVELOPMENT.md
index 136ff088..72e3f496 100644
--- a/DEVELOPMENT.md
+++ b/DEVELOPMENT.md
@@ -46,6 +46,8 @@ The PlanqTN Studio involves a couple of components:
 - the [Web UI](#web-ui-features) is a ReactJS/Vite web app, running as a Cloud Run Service in the hosted version
 - the [API](#planqtn-api) is a web service to serve relatively fast, but non-JS implemented logic
 - the [Jobs](#planqtn-background-jobs) are are for executing long running computaitons
+- the [Edge functions](#planqtn-edge-functions)
+- the [Types](#planqtn-types)
 
 We use GCP Cloud Run for executing workloads and the API and we use Supabase for realtime messaging, database, authentication.
 It is important to understand the concepts of User context and Runtime context
@@ -292,6 +294,20 @@ To develop with these functions, locally it is recommended to use the reload fun
 find supabase -name '*.ts' | entr -r npx supabase functions deploy planqtn_job_run
 ```
 
+## PlanqTN Types
+
+PlanqTN Types define the data interface between different components. The following categories of types are used in both Python components and Typescript components and hence need careful consideration when changing them.
+
+- PlanqTN API calls request and response JSON objects
+- PlanqTN Database Schema:
+  - authentication and quotas
+  - PlanqTN Jobs task management
+    - task definitions and results
+    - progress report update JSON objects that are stored in a Supabase table
+- PlanqTN Studio encoded canvas state JSON objects - to export into JSON files, encoded URL state and copy-paste features
+
+At the moment these are a bit all over the place, but eventually we should have a nice centralized, automated way of keeping in sync the Python and the Typescript definitions. Track https://github.com/planqtn/planqtn/issues/112 for updates on this.
+
 # Reference for developer tools
 
 ## Personal cloud setup
diff --git a/app/planqtn_api/css_tanner_network_test.py b/app/planqtn_api/css_tanner_network_test.py
index 7b61cc2d..521d5d64 100644
--- a/app/planqtn_api/css_tanner_network_test.py
+++ b/app/planqtn_api/css_tanner_network_test.py
@@ -55,8 +55,8 @@ def test_css_tanner_network_bell_state():
 
     # Count usage of each leg
     for conn in data["connections"]:
-        from_key = f"{conn['from']['legoId']}-{conn['from']['legIndex']}"
-        to_key = f"{conn['to']['legoId']}-{conn['to']['legIndex']}"
+        from_key = f"{conn['from']['legoId']}-{conn['from']['leg_index']}"
+        to_key = f"{conn['to']['legoId']}-{conn['to']['leg_index']}"
 
         leg_usage[from_key] = leg_usage.get(from_key, 0) + 1
         leg_usage[to_key] = leg_usage.get(to_key, 0) + 1
diff --git a/app/planqtn_jobs/test_files/sample_job1.json b/app/planqtn_jobs/test_files/sample_job1.json
index 41861907..d815bc64 100644
--- a/app/planqtn_jobs/test_files/sample_job1.json
+++ b/app/planqtn_jobs/test_files/sample_job1.json
@@ -1,8 +1,8 @@
 {
   "legos": {
     "3": {
-      "instanceId": "3",
-      "shortName": "[[8,3,2]]",
+      "instance_id": "3",
+      "short_name": "[[8,3,2]]",
       "name": "[[8,3,2]]",
       "id": "832",
       "parity_check_matrix": [
@@ -22,8 +22,8 @@
       "gauge_legs": []
     },
     "4": {
-      "instanceId": "4",
-      "shortName": "QRM15",
+      "instance_id": "4",
+      "short_name": "QRM15",
       "name": "QRM15",
       "id": "15qrm",
       "parity_check_matrix": [
@@ -98,10 +98,10 @@
   },
   "connections": [
     {
-      "from": { "legoId": "3", "legIndex": 10 },
-      "to": { "legoId": "4", "legIndex": 10 }
+      "from": { "legoId": "3", "leg_index": 10 },
+      "to": { "legoId": "4", "leg_index": 10 }
     }
   ],
   "truncate_length": null,
-  "open_legs": [{ "instanceId": "3", "legIndex": 7 }]
+  "open_legs": [{ "instance_id": "3", "leg_index": 7 }]
 }
diff --git a/app/planqtn_jobs/test_files/sample_job2.json b/app/planqtn_jobs/test_files/sample_job2.json
index 45daac52..2d2c690d 100644
--- a/app/planqtn_jobs/test_files/sample_job2.json
+++ b/app/planqtn_jobs/test_files/sample_job2.json
@@ -1,8 +1,8 @@
 {
   "legos": {
     "1": {
-      "instanceId": "1",
-      "shortName": "QRM15",
+      "instance_id": "1",
+      "short_name": "QRM15",
       "name": "QRM15",
       "id": "15qrm",
       "parity_check_matrix": [
diff --git a/app/planqtn_jobs/weight_enum_task.py b/app/planqtn_jobs/weight_enum_task.py
index ad75f9b6..6b939e47 100644
--- a/app/planqtn_jobs/weight_enum_task.py
+++ b/app/planqtn_jobs/weight_enum_task.py
@@ -67,11 +67,11 @@ class WeightEnumeratorTask(
                 tn.self_trace(
                     conn["from"]["legoId"],
                     conn["to"]["legoId"],
-                    [conn["from"]["legIndex"]],
-                    [conn["to"]["legIndex"]],
+                    [conn["from"]["leg_index"]],
+                    [conn["to"]["leg_index"]],
                 )
 
-            open_legs = [(leg.instanceId, leg.legIndex) for leg in args.open_legs]
+            open_legs = [(leg.instance_id, leg.leg_index) for leg in args.open_legs]
 
             start = time.time()
             print("debug", self.debug)
diff --git a/app/planqtn_jobs/weight_enum_task_test.py b/app/planqtn_jobs/weight_enum_task_test.py
index d12b7ea4..9a7573de 100644
--- a/app/planqtn_jobs/weight_enum_task_test.py
+++ b/app/planqtn_jobs/weight_enum_task_test.py
@@ -28,7 +28,7 @@ from google.protobuf import any_pb2
 from google.cloud.run_v2.types.execution import Execution as ExecutionProto
 
 # Test data from weight_enum_task_test.py
-TEST_JSON = """{"legos":{"1":{"instanceId":"1","shortName":"STN","name":"STN","id":"steane","parity_check_matrix":[[0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0],[0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0],[1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0],[0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0],[1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1]],"logical_legs":[7],"gauge_legs":[]},"2":{"instanceId":"2","shortName":"STN","name":"STN","id":"steane","parity_check_matrix":[[0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0],[0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0],[1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0],[0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0],[1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1]],"logical_legs":[7],"gauge_legs":[]}},"connections":[{"from":{"legoId":"1","legIndex":1},"to":{"legoId":"2","legIndex":5}}],"truncate_length":3,"open_legs":[{"instanceId":"1","legIndex":3},{"instanceId":"1","legIndex":6}]}"""
+TEST_JSON = """{"legos":{"1":{"instance_id":"1","short_name":"STN","name":"STN","type_id":"steane","parity_check_matrix":[[0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0],[0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0],[1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0],[0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0],[1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1]],"logical_legs":[7],"gauge_legs":[]},"2":{"instance_id":"2","short_name":"STN","name":"STN","type_id":"steane","parity_check_matrix":[[0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0],[0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0],[1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0],[0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0],[0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0],[1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1]],"logical_legs":[7],"gauge_legs":[]}},"connections":[{"from":{"legoId":"1","leg_index":1},"to":{"legoId":"2","leg_index":5}}],"truncate_length":3,"open_legs":[{"instance_id":"1","leg_index":3},{"instance_id":"1","leg_index":6}]}"""
 
 
 @pytest.fixture
@@ -199,7 +199,7 @@ async def test_main_with_task_store_and_realtime(
         "uuid": task_uuid,
         "user_id": supabase_setup["test_user_id"],
         # fmt: off
-        "args": json.loads("""{"legos":{"1":{"instanceId":"1","shortName":"QRM15","name":"QRM15","id":"15qrm","parity_check_matrix":[[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0],[0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,1]],"logical_legs":[15],"gauge_legs":[]}},"connections":[],"truncate_length":null,"open_legs":[]}"""),
+        "args": json.loads("""{"legos":{"1":{"instance_id":"1","short_name":"QRM15","name":"QRM15","type_id":"15qrm","parity_check_matrix":[[1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0,0,1,1,0,0,1,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0,0,0,0,1,1,1,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,1,0,0,0,1,0,0,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,0,0,0,0,1,0,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,0,0,0,0,1,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,0,0,1,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,1,1,1,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,1,0,1,0,1,0],[0,0,1,0,1,1,0,0,1,1,0,1,0,0,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,0,0,1,0,1,0,1]],"logical_legs":[15],"gauge_legs":[]}},"connections":[],"truncate_length":null,"open_legs":[]}"""),
         # fmt: on
         "state": 0,  # PENDING
         "job_type": "weight_enumerator",
diff --git a/app/planqtn_types/api_types.py b/app/planqtn_types/api_types.py
index ad444ae4..4ca3e36a 100644
--- a/app/planqtn_types/api_types.py
+++ b/app/planqtn_types/api_types.py
@@ -1,19 +1,19 @@
 from typing import Any, Dict, List
 
 from galois import GF2
-from pydantic import BaseModel
+from pydantic import BaseModel, Field
 from planqtn.stabilizer_tensor_enumerator import StabilizerCodeTensorEnumerator
 from planqtn.tensor_network import TensorNetwork
 
 
 class LegoPiece(BaseModel):
-    id: str
-    instanceId: str = ""
+    type_id: str
+    instance_id: str = ""
     name: str = ""
-    shortName: str
+    short_name: str
     description: str = ""
-    is_dynamic: bool = False
-    parameters: Dict[str, Any] = {}
+    is_dynamic: bool = Field(default=False)
+    parameters: Dict[str, Any] = Field(default_factory=dict)
     parity_check_matrix: List[List[int]]
     logical_legs: List[int] = []
     gauge_legs: List[int] = []
@@ -25,13 +25,13 @@ class TensorNetworkRequest(BaseModel):
 
 
 class TensorNetworkLeg(BaseModel):
-    instanceId: str
-    legIndex: int
+    instance_id: str
+    leg_index: int
 
 
 class WeightEnumeratorCalculationArgs(TensorNetworkRequest):
     truncate_length: int | None = None
-    open_legs: List[TensorNetworkLeg] = []
+    open_legs: List[TensorNetworkLeg] = Field(default_factory=list)
 
 
 class WeightEnumeratorCalculationResult(BaseModel):
@@ -42,19 +42,18 @@ class WeightEnumeratorCalculationResult(BaseModel):
 
 class TannerRequest(BaseModel):
     matrix: List[List[int]]
-    start_node_index: int = 0
+    start_node_index: int = Field(default=0)
 
 
 class TensorNetworkResponse(BaseModel):
     legos: List[Dict[str, Any]]
     connections: List[Dict[str, Any]]
-    message: str = "Successfully created Tanner network"
 
     def to_tensor_network(self):
 
         nodes = [
             StabilizerCodeTensorEnumerator(
-                idx=lego["instanceId"], h=GF2(lego["parity_check_matrix"])
+                idx=lego["instance_id"], h=GF2(lego["parity_check_matrix"])
             )
             for lego in self.legos
         ]
@@ -64,8 +63,8 @@ class TensorNetworkResponse(BaseModel):
             tn.self_trace(
                 conn["from"]["legoId"],
                 conn["to"]["legoId"],
-                [conn["from"]["legIndex"]],
-                [conn["to"]["legIndex"]],
+                [conn["from"]["leg_index"]],
+                [conn["to"]["leg_index"]],
             )
 
         return tn
@@ -89,9 +88,9 @@ class TensorNetworkResponse(BaseModel):
             else:
                 lego_type = "generic"
             lego = {
-                "instanceId": str(i + start_node_index),
-                "id": lego_type,
-                "shortName": instance_id,
+                "instance_id": str(i + start_node_index),
+                "type_id": lego_type,
+                "short_name": instance_id,
                 "description": instance_id,
                 "x": (
                     piece.annotation.x
@@ -107,7 +106,7 @@ class TensorNetworkResponse(BaseModel):
                 "logical_legs": [],
                 "gauge_legs": [],
             }
-            # print("lego", lego["shortName"], "x", lego["x"], "y", lego["y"])
+            # print("lego", lego["short_name"], "x", lego["x"], "y", lego["y"])
             legos.append(lego)
             instance_id_to_idx[instance_id] = i + start_node_index
         # Add connections from the tensor network's traces
@@ -117,11 +116,11 @@ class TensorNetworkResponse(BaseModel):
                     {
                         "from": {
                             "legoId": str(instance_id_to_idx[node1]),
-                            "legIndex": tn.nodes[node1].legs.index(leg1),
+                            "leg_index": tn.nodes[node1].legs.index(leg1),
                         },
                         "to": {
                             "legoId": str(instance_id_to_idx[node2]),
-                            "legIndex": tn.nodes[node2].legs.index(leg2),
+                            "leg_index": tn.nodes[node2].legs.index(leg2),
                         },
                     }
                 )
diff --git a/app/ui/hack/rerun b/app/ui/hack/rerun
index d46b812a..594698a6 100755
--- a/app/ui/hack/rerun
+++ b/app/ui/hack/rerun
@@ -1,5 +1,13 @@
 #!/bin/bash
 
-export PYTHONPATH=".."
+
+
+# ensure that this is ran from the ui directory
+if [ ! -f "./src/main.tsx" ]; then
+  echo "Please run this script from the app/ui directory"
+  exit 1
+fi
+
+export PYTHONPATH="`pwd`/../.."
 
 find . -type f -name '*.ts*' | entr -r $@
\ No newline at end of file
diff --git a/app/ui/package-lock.json b/app/ui/package-lock.json
index cdbbc330..00086759 100644
--- a/app/ui/package-lock.json
+++ b/app/ui/package-lock.json
@@ -14,6 +14,7 @@
         "@emotion/styled": "^11.11.0",
         "@supabase/supabase-js": "^2.49.4",
         "@types/d3-force": "^3.0.10",
+        "ajv": "^8.17.1",
         "axios": "^1.6.7",
         "connect-history-api-fallback": "^2.0.0",
         "d3-force": "^3.0.0",
@@ -1418,6 +1419,23 @@
         "url": "https://opencollective.com/eslint"
       }
     },
+    "node_modules/@eslint/eslintrc/node_modules/ajv": {
+      "version": "6.12.6",
+      "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz",
+      "integrity": "sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "fast-deep-equal": "^3.1.1",
+        "fast-json-stable-stringify": "^2.0.0",
+        "json-schema-traverse": "^0.4.1",
+        "uri-js": "^4.2.2"
+      },
+      "funding": {
+        "type": "github",
+        "url": "https://github.com/sponsors/epoberezkin"
+      }
+    },
     "node_modules/@eslint/eslintrc/node_modules/brace-expansion": {
       "version": "1.1.12",
       "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.12.tgz",
@@ -1442,6 +1460,13 @@
         "url": "https://github.com/sponsors/sindresorhus"
       }
     },
+    "node_modules/@eslint/eslintrc/node_modules/json-schema-traverse": {
+      "version": "0.4.1",
+      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
+      "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/@eslint/eslintrc/node_modules/minimatch": {
       "version": "3.1.2",
       "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
@@ -3633,16 +3658,15 @@
       }
     },
     "node_modules/ajv": {
-      "version": "6.12.6",
-      "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz",
-      "integrity": "sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==",
-      "dev": true,
+      "version": "8.17.1",
+      "resolved": "https://registry.npmjs.org/ajv/-/ajv-8.17.1.tgz",
+      "integrity": "sha512-B/gBuNg5SiMTrPkC+A2+cW0RszwxYmn6VYxB/inlBStS5nx6xHIt/ehKRhIMhqusl7a8LjQoZnjCs5vhwxOQ1g==",
       "license": "MIT",
       "dependencies": {
-        "fast-deep-equal": "^3.1.1",
-        "fast-json-stable-stringify": "^2.0.0",
-        "json-schema-traverse": "^0.4.1",
-        "uri-js": "^4.2.2"
+        "fast-deep-equal": "^3.1.3",
+        "fast-uri": "^3.0.1",
+        "json-schema-traverse": "^1.0.0",
+        "require-from-string": "^2.0.2"
       },
       "funding": {
         "type": "github",
@@ -5379,6 +5403,23 @@
         "node": "^18.18.0 || ^20.9.0 || >=21.1.0"
       }
     },
+    "node_modules/eslint/node_modules/ajv": {
+      "version": "6.12.6",
+      "resolved": "https://registry.npmjs.org/ajv/-/ajv-6.12.6.tgz",
+      "integrity": "sha512-j3fVLgvTo527anyYyJOGTYJbG+vnnQYvE0m5mmkc1TK+nxAppkCLMIL0aZ4dblVCNoGShhm+kzE4ZUykBoMg4g==",
+      "dev": true,
+      "license": "MIT",
+      "dependencies": {
+        "fast-deep-equal": "^3.1.1",
+        "fast-json-stable-stringify": "^2.0.0",
+        "json-schema-traverse": "^0.4.1",
+        "uri-js": "^4.2.2"
+      },
+      "funding": {
+        "type": "github",
+        "url": "https://github.com/sponsors/epoberezkin"
+      }
+    },
     "node_modules/eslint/node_modules/brace-expansion": {
       "version": "1.1.12",
       "resolved": "https://registry.npmjs.org/brace-expansion/-/brace-expansion-1.1.12.tgz",
@@ -5403,6 +5444,13 @@
         "url": "https://opencollective.com/eslint"
       }
     },
+    "node_modules/eslint/node_modules/json-schema-traverse": {
+      "version": "0.4.1",
+      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
+      "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==",
+      "dev": true,
+      "license": "MIT"
+    },
     "node_modules/eslint/node_modules/minimatch": {
       "version": "3.1.2",
       "resolved": "https://registry.npmjs.org/minimatch/-/minimatch-3.1.2.tgz",
@@ -5687,7 +5735,6 @@
       "version": "3.1.3",
       "resolved": "https://registry.npmjs.org/fast-deep-equal/-/fast-deep-equal-3.1.3.tgz",
       "integrity": "sha512-f3qQ9oQy9j2AhBe/H9VC91wLmKBCCU/gDOnKNAYG5hswO7BLKj09Hc5HYNz9cGI++xlpDCIgDaitVs03ATR84Q==",
-      "dev": true,
       "license": "MIT"
     },
     "node_modules/fast-glob": {
@@ -5734,6 +5781,22 @@
       "dev": true,
       "license": "MIT"
     },
+    "node_modules/fast-uri": {
+      "version": "3.0.6",
+      "resolved": "https://registry.npmjs.org/fast-uri/-/fast-uri-3.0.6.tgz",
+      "integrity": "sha512-Atfo14OibSv5wAp4VWNsFYE1AchQRTv9cBGWET4pZWHzYshFSS9NQI6I57rdKn9croWVMbYFbLhJ+yJvmZIIHw==",
+      "funding": [
+        {
+          "type": "github",
+          "url": "https://github.com/sponsors/fastify"
+        },
+        {
+          "type": "opencollective",
+          "url": "https://opencollective.com/fastify"
+        }
+      ],
+      "license": "BSD-3-Clause"
+    },
     "node_modules/fastq": {
       "version": "1.19.1",
       "resolved": "https://registry.npmjs.org/fastq/-/fastq-1.19.1.tgz",
@@ -7776,10 +7839,9 @@
       "license": "MIT"
     },
     "node_modules/json-schema-traverse": {
-      "version": "0.4.1",
-      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-0.4.1.tgz",
-      "integrity": "sha512-xbbCH5dCYU5T8LcEhhuh7HJ88HXuW3qsI3Y0zOZFKfZEHcpWiHU/Jxzk629Brsab/mMiHQti9wMP+845RPe3Vg==",
-      "dev": true,
+      "version": "1.0.0",
+      "resolved": "https://registry.npmjs.org/json-schema-traverse/-/json-schema-traverse-1.0.0.tgz",
+      "integrity": "sha512-NM8/P9n3XjXhIZn1lLhkFaACTOURQXjWhV4BA/RnOv8xvgqtqpAX9IO4mRQxSx1Rlo4tqzeqb0sOlruaOy3dug==",
       "license": "MIT"
     },
     "node_modules/json-stable-stringify-without-jsonify": {
@@ -9109,6 +9171,15 @@
         "node": ">=0.10.0"
       }
     },
+    "node_modules/require-from-string": {
+      "version": "2.0.2",
+      "resolved": "https://registry.npmjs.org/require-from-string/-/require-from-string-2.0.2.tgz",
+      "integrity": "sha512-Xf0nWe6RseziFMu+Ap9biiUbmplq6S9/p+7w7YXP/JBHhrUDDUhwa+vANyubuqfZWTveU//DYVGsDG7RKL/vEw==",
+      "license": "MIT",
+      "engines": {
+        "node": ">=0.10.0"
+      }
+    },
     "node_modules/requires-port": {
       "version": "1.0.0",
       "resolved": "https://registry.npmjs.org/requires-port/-/requires-port-1.0.0.tgz",
diff --git a/app/ui/package.json b/app/ui/package.json
index 6a8b8b02..32af90f9 100644
--- a/app/ui/package.json
+++ b/app/ui/package.json
@@ -18,6 +18,7 @@
     "@emotion/styled": "^11.11.0",
     "@supabase/supabase-js": "^2.49.4",
     "@types/d3-force": "^3.0.10",
+    "ajv": "^8.17.1",
     "axios": "^1.6.7",
     "connect-history-api-fallback": "^2.0.0",
     "d3-force": "^3.0.0",
diff --git a/app/ui/src/components/ModalRoot.tsx b/app/ui/src/components/ModalRoot.tsx
index 1a0e43ce..02f0c5d9 100644
--- a/app/ui/src/components/ModalRoot.tsx
+++ b/app/ui/src/components/ModalRoot.tsx
@@ -127,12 +127,12 @@ export const ModalRoot: React.FC<ModalRootProps> = ({
 
   const handleCustomLegoSubmit = async (
     matrix: number[][],
-    logicalLegs: number[]
+    logical_legs: number[]
   ) => {
     try {
       CustomLegoService.createCustomLego(
         matrix,
-        logicalLegs,
+        logical_legs,
         customLegoState.position
       );
       toast({
diff --git a/app/ui/src/config/__mocks__/config.ts b/app/ui/src/config/__mocks__/config.ts
new file mode 100644
index 00000000..7b6346c8
--- /dev/null
+++ b/app/ui/src/config/__mocks__/config.ts
@@ -0,0 +1,6 @@
+export const config = {
+  userContextURL: "mocked-url" // Mock value
+  // Add other mock configurations as needed
+};
+
+export const getApiUrl = (endpoint: string) => `mocked-api-url/${endpoint}`;
diff --git a/app/ui/src/features/auth/__mocks__/auth.ts b/app/ui/src/features/auth/__mocks__/auth.ts
new file mode 100644
index 00000000..cc860edd
--- /dev/null
+++ b/app/ui/src/features/auth/__mocks__/auth.ts
@@ -0,0 +1,3 @@
+export async function getAccessToken(): Promise<string | null> {
+  return "mocked-access-token";
+}
diff --git a/app/ui/src/lib/auth.ts b/app/ui/src/features/auth/auth.ts
similarity index 84%
rename from app/ui/src/lib/auth.ts
rename to app/ui/src/features/auth/auth.ts
index 6c217750..52439e0e 100644
--- a/app/ui/src/lib/auth.ts
+++ b/app/ui/src/features/auth/auth.ts
@@ -1,4 +1,4 @@
-import { userContextSupabase } from "../config/supabaseClient";
+import { userContextSupabase } from "../../config/supabaseClient";
 
 export async function getAccessToken(): Promise<string | null> {
   if (!userContextSupabase) {
diff --git a/app/ui/src/features/building-blocks-panel/BuildingBlocksPanel.tsx b/app/ui/src/features/building-blocks-panel/BuildingBlocksPanel.tsx
index a1421e2d..5499a672 100644
--- a/app/ui/src/features/building-blocks-panel/BuildingBlocksPanel.tsx
+++ b/app/ui/src/features/building-blocks-panel/BuildingBlocksPanel.tsx
@@ -34,7 +34,7 @@ interface BuildingBlocksPanelProps {
 const customLego: LegoPiece = {
   type_id: "custom",
   name: "Custom Lego",
-  shortName: "Custom",
+  short_name: "Custom",
   description:
     "Create a custom lego with specified parity check matrix and logical legs",
   parity_check_matrix: [
diff --git a/app/ui/src/features/canvas/CanvasMouseHandler.tsx b/app/ui/src/features/canvas/CanvasMouseHandler.tsx
index f7316b28..2e87d90a 100644
--- a/app/ui/src/features/canvas/CanvasMouseHandler.tsx
+++ b/app/ui/src/features/canvas/CanvasMouseHandler.tsx
@@ -96,23 +96,24 @@ export const CanvasMouseHandler: React.FC<CanvasMouseHandlerProps> = ({
 
       // Get the dragged lego BEFORE updating the array to avoid stale references
       const draggedLego = droppedLegos.find(
-        (lego) => lego.instanceId === legoDragState.draggedLegoInstanceId
+        (lego) => lego.instance_id === legoDragState.draggedLegoInstanceId
       );
       if (!draggedLego) return;
 
       const legosToUpdate = droppedLegos.filter(
         (lego) =>
-          lego.instanceId === legoDragState.draggedLegoInstanceId ||
-          groupDragState?.legoInstanceIds.includes(lego.instanceId)
+          lego.instance_id === legoDragState.draggedLegoInstanceId ||
+          groupDragState?.legoInstanceIds.includes(lego.instance_id)
       );
 
       const updatedLegos = legosToUpdate.map((lego) => {
         if (
           groupDragState &&
-          groupDragState.legoInstanceIds.includes(lego.instanceId)
+          groupDragState.legoInstanceIds.includes(lego.instance_id)
         ) {
           // Move all selected legos together using canvas deltas
-          const originalPos = groupDragState.originalPositions[lego.instanceId];
+          const originalPos =
+            groupDragState.originalPositions[lego.instance_id];
           return {
             oldLego: lego,
             updatedLego: lego.with({
@@ -146,7 +147,7 @@ export const CanvasMouseHandler: React.FC<CanvasMouseHandlerProps> = ({
           const updatedNetworkLegos = updatedLegos
             .filter((update) =>
               groupDragState.legoInstanceIds.includes(
-                update.updatedLego.instanceId
+                update.updatedLego.instance_id
               )
             )
             .map((update) => update.updatedLego);
@@ -228,11 +229,11 @@ export const CanvasMouseHandler: React.FC<CanvasMouseHandlerProps> = ({
         );
         if (Math.abs(mouseDelta.x) > 1 || Math.abs(mouseDelta.y) > 1) {
           const draggedLego = droppedLegos.find(
-            (lego) => lego.instanceId === legoDragState.draggedLegoInstanceId
+            (lego) => lego.instance_id === legoDragState.draggedLegoInstanceId
           );
           if (!draggedLego) return;
           const isPartOfSelection = tensorNetwork?.legos.some(
-            (l) => l.instanceId === draggedLego.instanceId
+            (l) => l.instance_id === draggedLego.instance_id
           );
           if (!isPartOfSelection) {
             setTensorNetwork(
@@ -290,7 +291,7 @@ export const CanvasMouseHandler: React.FC<CanvasMouseHandlerProps> = ({
 
         // Check if the dragged lego is a stopper and handle stopper logic
         const draggedLego = droppedLegos.find(
-          (lego) => lego.instanceId === legoDragState.draggedLegoInstanceId
+          (lego) => lego.instance_id === legoDragState.draggedLegoInstanceId
         );
         if (!draggedLego) return;
 
@@ -404,7 +405,7 @@ export const CanvasMouseHandler: React.FC<CanvasMouseHandlerProps> = ({
 
         // Check if this lego already has connections - if so, just do regular move
         const hasExistingConnections = connectedLegos.some(
-          (connectedLego) => connectedLego.instanceId === lego.instanceId
+          (connectedLego) => connectedLego.instance_id === lego.instance_id
         );
 
         if (hasExistingConnections || !closestConnection) {
@@ -415,13 +416,13 @@ export const CanvasMouseHandler: React.FC<CanvasMouseHandlerProps> = ({
         const repositionedLego = new DroppedLego(
           lego,
           dropPosition,
-          existingLegoToRemove?.instanceId || newInstanceId()
+          existingLegoToRemove?.instance_id || newInstanceId()
         );
 
         // Remove the original lego if we're moving an existing one
         const legosForCalculation = existingLegoToRemove
           ? droppedLegos.filter(
-              (l) => l.instanceId !== existingLegoToRemove.instanceId
+              (l) => l.instance_id !== existingLegoToRemove.instance_id
             )
           : droppedLegos;
 
@@ -457,7 +458,7 @@ export const CanvasMouseHandler: React.FC<CanvasMouseHandlerProps> = ({
           // If we're moving an existing stopper, remove it first
           const legosForCalculation = existingLegoToRemove
             ? droppedLegos.filter(
-                (lego) => lego.instanceId !== existingLegoToRemove.instanceId
+                (lego) => lego.instance_id !== existingLegoToRemove.instance_id
               )
             : droppedLegos;
 
@@ -465,13 +466,13 @@ export const CanvasMouseHandler: React.FC<CanvasMouseHandlerProps> = ({
           const stopperLego: DroppedLego = new DroppedLego(
             draggedLego,
             dropPosition,
-            existingLegoToRemove?.instanceId || newInstanceId()
+            existingLegoToRemove?.instance_id || newInstanceId()
           );
 
           const addStopper = new AddStopper(connections, legosForCalculation);
           const result = addStopper.apply(
             closestLeg.lego,
-            closestLeg.legIndex,
+            closestLeg.leg_index,
             stopperLego
           );
           setLegosAndConnections(result.droppedLegos, result.connections);
diff --git a/app/ui/src/features/canvas/CanvasStateSerializer.ts b/app/ui/src/features/canvas/CanvasStateSerializer.ts
index 78244bc4..86e11976 100644
--- a/app/ui/src/features/canvas/CanvasStateSerializer.ts
+++ b/app/ui/src/features/canvas/CanvasStateSerializer.ts
@@ -2,12 +2,13 @@ import { Connection } from "../../stores/connectionStore";
 import { DroppedLego } from "../../stores/droppedLegoStore";
 import { LogicalPoint } from "../../types/coordinates";
 import { Legos } from "../lego/Legos";
+import { validateEncodedCanvasState } from "../../schemas/v1/canvas-state-validator";
 
 interface CanvasState {
   canvasId: string;
   pieces: Array<{
     id: string;
-    instanceId: string;
+    instance_id: string;
     x: number;
     y: number;
     is_dynamic?: boolean;
@@ -50,10 +51,10 @@ export class CanvasStateSerializer {
       canvasId: this.canvasId,
       pieces: pieces.map((piece) => ({
         id: piece.type_id,
-        instanceId: piece.instanceId,
+        instance_id: piece.instance_id,
         x: piece.logicalPosition.x,
         y: piece.logicalPosition.y,
-        shortName: piece.shortName,
+        short_name: piece.short_name,
         is_dynamic: piece.is_dynamic,
         parameters: piece.parameters,
         parity_check_matrix: piece.parity_check_matrix,
@@ -77,7 +78,20 @@ export class CanvasStateSerializer {
     canvasId: string;
   }> {
     try {
+      // Validate the encoded state first
+      const validationResult = validateEncodedCanvasState(encoded);
+      if (!validationResult.isValid) {
+        console.error(
+          "Canvas state validation failed:",
+          validationResult.errors
+        );
+        throw new Error(
+          `Invalid canvas state: ${validationResult.errors?.join(", ")}`
+        );
+      }
+
       const decoded = JSON.parse(atob(encoded));
+      console.log("Decoded state:", decoded);
       if (!decoded.pieces || !Array.isArray(decoded.pieces)) {
         return {
           pieces: [],
@@ -99,7 +113,7 @@ export class CanvasStateSerializer {
       const reconstructedPieces = decoded.pieces.map(
         (piece: {
           id: string;
-          instanceId: string;
+          instance_id: string;
           x: number;
           y: number;
           is_dynamic?: boolean;
@@ -108,7 +122,7 @@ export class CanvasStateSerializer {
           logical_legs?: number[];
           gauge_legs?: number[];
           name?: string;
-          shortName?: string;
+          short_name?: string;
           description?: string;
           selectedMatrixRows?: number[];
         }) => {
@@ -118,7 +132,7 @@ export class CanvasStateSerializer {
             piece.parity_check_matrix.length === 0
           ) {
             throw new Error(
-              `Piece ${piece.instanceId} (of type ${piece.id}) has no parity check matrix. Full state:\n${atob(encoded)}`
+              `Piece ${piece.instance_id} (of type ${piece.id}) has no parity check matrix. Full state:\n${atob(encoded)}`
             );
           }
 
@@ -128,7 +142,7 @@ export class CanvasStateSerializer {
               {
                 type_id: piece.id,
                 name: piece.name || piece.id,
-                shortName: piece.shortName || piece.id,
+                short_name: piece.short_name || piece.id,
                 description: piece.description || "",
 
                 is_dynamic: piece.is_dynamic || false,
@@ -138,7 +152,7 @@ export class CanvasStateSerializer {
                 gauge_legs: piece.gauge_legs || []
               },
               new LogicalPoint(piece.x, piece.y),
-              piece.instanceId,
+              piece.instance_id,
               { selectedMatrixRows: piece.selectedMatrixRows || [] }
             );
           }
@@ -159,7 +173,7 @@ export class CanvasStateSerializer {
               },
 
               new LogicalPoint(piece.x, piece.y),
-              piece.instanceId,
+              piece.instance_id,
 
               { selectedMatrixRows: piece.selectedMatrixRows || [] }
             );
@@ -173,7 +187,7 @@ export class CanvasStateSerializer {
                 piece.parity_check_matrix || predefinedLego.parity_check_matrix
             },
             new LogicalPoint(piece.x, piece.y),
-            piece.instanceId,
+            piece.instance_id,
             { selectedMatrixRows: piece.selectedMatrixRows || [] }
           );
         }
diff --git a/app/ui/src/features/canvas/KeyboardHandler.tsx b/app/ui/src/features/canvas/KeyboardHandler.tsx
index 06c002f7..0e338435 100644
--- a/app/ui/src/features/canvas/KeyboardHandler.tsx
+++ b/app/ui/src/features/canvas/KeyboardHandler.tsx
@@ -60,7 +60,7 @@ export const KeyboardHandler: React.FC<KeyboardHandlerProps> = ({
         if (tensorNetwork && tensorNetwork.legos.length > 0) {
           const selectedLegos = tensorNetwork.legos;
           const selectedLegoIds = new Set(
-            selectedLegos.map((l: DroppedLego) => l.instanceId)
+            selectedLegos.map((l: DroppedLego) => l.instance_id)
           );
 
           const selectedConnections = connections.filter(
@@ -140,7 +140,7 @@ export const KeyboardHandler: React.FC<KeyboardHandlerProps> = ({
             const newLegos = pastedData.legos.map(
               (l: DroppedLego, idx: number) => {
                 const newId = String(startingId + idx);
-                instanceIdMap.set(l.instanceId, newId);
+                instanceIdMap.set(l.instance_id, newId);
                 // Style will be recalculated in DroppedLego constructor
                 return new DroppedLego(
                   l,
@@ -163,11 +163,11 @@ export const KeyboardHandler: React.FC<KeyboardHandlerProps> = ({
                 return {
                   from: {
                     legoId: instanceIdMap.get(conn.from.legoId)!,
-                    legIndex: conn.from.legIndex
+                    leg_index: conn.from.leg_index
                   },
                   to: {
                     legoId: instanceIdMap.get(conn.to.legoId)!,
-                    legIndex: conn.to.legIndex
+                    leg_index: conn.to.leg_index
                   }
                 };
               }
@@ -219,8 +219,8 @@ export const KeyboardHandler: React.FC<KeyboardHandlerProps> = ({
           const connectionsToRemove = connections.filter((conn) =>
             legosToRemove.some(
               (lego) =>
-                conn.from.legoId === lego.instanceId ||
-                conn.to.legoId === lego.instanceId
+                conn.from.legoId === lego.instance_id ||
+                conn.to.legoId === lego.instance_id
             )
           );
 
@@ -238,12 +238,12 @@ export const KeyboardHandler: React.FC<KeyboardHandlerProps> = ({
             connections.filter((conn) =>
               legosToRemove.some(
                 (lego) =>
-                  conn.from.legoId === lego.instanceId ||
-                  conn.to.legoId === lego.instanceId
+                  conn.from.legoId === lego.instance_id ||
+                  conn.to.legoId === lego.instance_id
               )
             )
           );
-          removeDroppedLegos(legosToRemove.map((l) => l.instanceId));
+          removeDroppedLegos(legosToRemove.map((l) => l.instance_id));
         }
       } else if ((e.ctrlKey || e.metaKey) && e.key === "a") {
         e.preventDefault();
diff --git a/app/ui/src/features/canvas/OperationHistory.test.ts b/app/ui/src/features/canvas/OperationHistory.test.ts
index f071a6d1..efd88515 100644
--- a/app/ui/src/features/canvas/OperationHistory.test.ts
+++ b/app/ui/src/features/canvas/OperationHistory.test.ts
@@ -18,7 +18,7 @@ describe("OperationHistory", () => {
         {
           type_id: "lego1",
           name: "Test Lego",
-          shortName: "TL",
+          short_name: "TL",
           description: "Test Description",
           parity_check_matrix: [
             [1, 0],
@@ -69,7 +69,7 @@ describe("OperationHistory", () => {
         {
           type_id: "lego1",
           name: "Test Lego",
-          shortName: "TL",
+          short_name: "TL",
           description: "Test Description",
           parity_check_matrix: [
             [1, 0],
@@ -146,7 +146,7 @@ describe("OperationHistory", () => {
         {
           type_id: "hadamard",
           name: "Hadamard",
-          shortName: "H",
+          short_name: "H",
           description: "Hadamard Gate",
           parity_check_matrix: [
             [1, 0],
@@ -163,7 +163,7 @@ describe("OperationHistory", () => {
         {
           type_id: "z-rep",
           name: "Z-Rep Code",
-          shortName: "Z",
+          short_name: "Z",
           description: "Z-Repetition Code",
           parity_check_matrix: [
             [0, 0, 0, 1, 1, 0],
@@ -178,7 +178,7 @@ describe("OperationHistory", () => {
       );
 
       const zRep2: DroppedLego = zRep1.with({
-        instanceId: "2",
+        instance_id: "2",
         logicalPosition: new LogicalPoint(200, 0)
       });
 
@@ -187,21 +187,21 @@ describe("OperationHistory", () => {
         new Connection(
           {
             legoId: "hadamard",
-            legIndex: 0
+            leg_index: 0
           },
           {
             legoId: "1",
-            legIndex: 0
+            leg_index: 0
           }
         ),
         new Connection(
           {
             legoId: "1",
-            legIndex: 1
+            leg_index: 1
           },
           {
             legoId: "2",
-            legIndex: 0
+            leg_index: 0
           }
         )
       ];
@@ -215,7 +215,7 @@ describe("OperationHistory", () => {
 
       // Fuse operation
       const fusedLego: DroppedLego = zRep1.with({
-        instanceId: "fused",
+        instance_id: "fused",
         parity_check_matrix: [
           [1, 1, 1, 1, 0, 0, 0, 0],
           [0, 0, 0, 0, 1, 1, 0, 0],
@@ -235,11 +235,11 @@ describe("OperationHistory", () => {
             new Connection(
               {
                 legoId: "h1",
-                legIndex: 0
+                leg_index: 0
               },
               {
                 legoId: "fused",
-                legIndex: 0
+                leg_index: 0
               }
             )
           ]
@@ -255,11 +255,11 @@ describe("OperationHistory", () => {
           new Connection(
             {
               legoId: "h1",
-              legIndex: 0
+              leg_index: 0
             },
             {
               legoId: "fused",
-              legIndex: 0
+              leg_index: 0
             }
           )
         ],
@@ -267,12 +267,12 @@ describe("OperationHistory", () => {
       };
 
       const zRep1_2: DroppedLego = zRep1.with({
-        instanceId: "zRep12",
+        instance_id: "zRep12",
         logicalPosition: new LogicalPoint(150, 0)
       });
 
       const zRep2_2: DroppedLego = zRep2.with({
-        instanceId: "zRep22",
+        instance_id: "zRep22",
         logicalPosition: new LogicalPoint(250, 0)
       });
 
@@ -282,21 +282,21 @@ describe("OperationHistory", () => {
           new Connection(
             {
               legoId: "h1",
-              legIndex: 0
+              leg_index: 0
             },
             {
               legoId: "zRep12",
-              legIndex: 0
+              leg_index: 0
             }
           ),
           new Connection(
             {
               legoId: "zRep12",
-              legIndex: 2
+              leg_index: 2
             },
             {
               legoId: "zRep22",
-              legIndex: 2
+              leg_index: 2
             }
           )
         ],
@@ -347,7 +347,7 @@ describe("OperationHistory", () => {
         {
           type_id: "lego1",
           name: "Test Lego",
-          shortName: "TL",
+          short_name: "TL",
           description: "Test Description",
           parity_check_matrix: [
             [1, 0],
@@ -378,7 +378,7 @@ describe("OperationHistory", () => {
         {
           type_id: "lego1",
           name: "Test Lego",
-          shortName: "TL",
+          short_name: "TL",
           description: "Test Description",
           parity_check_matrix: [
             [1, 0],
@@ -412,8 +412,8 @@ describe("OperationHistory", () => {
 
     it("should undo a connect operation", () => {
       const connection: Connection = new Connection(
-        { legoId: "instance1", legIndex: 0 },
-        { legoId: "instance2", legIndex: 1 }
+        { legoId: "instance1", leg_index: 0 },
+        { legoId: "instance2", leg_index: 1 }
       );
 
       const operation: Operation = {
@@ -441,7 +441,7 @@ describe("OperationHistory", () => {
         {
           type_id: "lego1",
           name: "Test Lego",
-          shortName: "TL",
+          short_name: "TL",
           description: "Test Description",
           parity_check_matrix: [
             [1, 0],
@@ -466,7 +466,7 @@ describe("OperationHistory", () => {
       const result = operationHistory.redo([], []);
 
       expect(result.droppedLegos).toHaveLength(1);
-      expect(result.droppedLegos[0].instanceId).toBe("instance1");
+      expect(result.droppedLegos[0].instance_id).toBe("instance1");
     });
 
     it("should redo a move operation", () => {
@@ -474,7 +474,7 @@ describe("OperationHistory", () => {
         {
           type_id: "lego1",
           name: "Test Lego",
-          shortName: "TL",
+          short_name: "TL",
           description: "Test Description",
           parity_check_matrix: [
             [1, 0],
@@ -509,8 +509,8 @@ describe("OperationHistory", () => {
 
     it("should redo a connect operation", () => {
       const connection: Connection = new Connection(
-        { legoId: "instance1", legIndex: 0 },
-        { legoId: "instance2", legIndex: 1 }
+        { legoId: "instance1", leg_index: 0 },
+        { legoId: "instance2", leg_index: 1 }
       );
 
       const operation: Operation = {
diff --git a/app/ui/src/features/canvas/OperationHistory.ts b/app/ui/src/features/canvas/OperationHistory.ts
index 2bbfd250..001fb849 100644
--- a/app/ui/src/features/canvas/OperationHistory.ts
+++ b/app/ui/src/features/canvas/OperationHistory.ts
@@ -73,7 +73,7 @@ export class OperationHistory {
     newDroppedLegos = newDroppedLegos.filter(
       (lego) =>
         !lastOperation.data?.legosToAdd?.some(
-          (removeMe) => removeMe.instanceId === lego.instanceId
+          (removeMe) => removeMe.instance_id === lego.instance_id
         )
     );
     // we add the ones that were removed
@@ -84,7 +84,7 @@ export class OperationHistory {
     // we update the ones that were updated
     newDroppedLegos = newDroppedLegos.map((lego) => {
       const update = lastOperation.data?.legosToUpdate?.find(
-        (updateMe) => updateMe.newLego.instanceId === lego.instanceId
+        (updateMe) => updateMe.newLego.instance_id === lego.instance_id
       );
       if (update) {
         return update.oldLego;
@@ -121,7 +121,7 @@ export class OperationHistory {
     newDroppedLegos = newDroppedLegos.filter(
       (lego) =>
         !nextOperation.data?.legosToRemove?.some(
-          (removeMe) => removeMe.instanceId === lego.instanceId
+          (removeMe) => removeMe.instance_id === lego.instance_id
         )
     );
     newDroppedLegos = [
@@ -130,7 +130,7 @@ export class OperationHistory {
     ];
     newDroppedLegos = newDroppedLegos.map((lego) => {
       const update = nextOperation.data?.legosToUpdate?.find(
-        (updateMe) => updateMe.oldLego.instanceId === lego.instanceId
+        (updateMe) => updateMe.oldLego.instance_id === lego.instance_id
       );
       if (update) {
         return update.newLego;
diff --git a/app/ui/src/features/canvas/SelectionManager.tsx b/app/ui/src/features/canvas/SelectionManager.tsx
index 1d101b23..319be54a 100644
--- a/app/ui/src/features/canvas/SelectionManager.tsx
+++ b/app/ui/src/features/canvas/SelectionManager.tsx
@@ -69,8 +69,8 @@ export const SelectionManager = memo(
               const newLegos = [...tensorNetwork.legos, ...selectedLegos];
               const newConnections = connections.filter(
                 (conn) =>
-                  newLegos.some((l) => l.instanceId === conn.from.legoId) &&
-                  newLegos.some((l) => l.instanceId === conn.to.legoId)
+                  newLegos.some((l) => l.instance_id === conn.from.legoId) &&
+                  newLegos.some((l) => l.instance_id === conn.to.legoId)
               );
               const newNetwork = new TensorNetwork({
                 legos: newLegos,
@@ -96,8 +96,8 @@ export const SelectionManager = memo(
               const newLegos = [...tensorNetwork.legos, ...selectedLegos];
               const newConnections = connections.filter(
                 (conn) =>
-                  newLegos.some((l) => l.instanceId === conn.from.legoId) &&
-                  newLegos.some((l) => l.instanceId === conn.to.legoId)
+                  newLegos.some((l) => l.instance_id === conn.from.legoId) &&
+                  newLegos.some((l) => l.instance_id === conn.to.legoId)
               );
               const newNetwork = new TensorNetwork({
                 legos: newLegos,
@@ -106,7 +106,7 @@ export const SelectionManager = memo(
               setTensorNetwork(newNetwork);
             } else {
               const selectedLegoIds = new Set(
-                selectedLegos.map((lego: DroppedLego) => lego.instanceId)
+                selectedLegos.map((lego: DroppedLego) => lego.instance_id)
               );
               const internalConnections = connections.filter(
                 (conn) =>
@@ -122,7 +122,7 @@ export const SelectionManager = memo(
           } else {
             // Create a tensor network from the selected legos
             const selectedLegoIds = new Set(
-              selectedLegos.map((lego: DroppedLego) => lego.instanceId)
+              selectedLegos.map((lego: DroppedLego) => lego.instance_id)
             );
             const internalConnections = connections.filter(
               (conn) =>
diff --git a/app/ui/src/features/canvas/ViewportDebugOverlay.tsx b/app/ui/src/features/canvas/ViewportDebugOverlay.tsx
index 7342552e..d99547f1 100644
--- a/app/ui/src/features/canvas/ViewportDebugOverlay.tsx
+++ b/app/ui/src/features/canvas/ViewportDebugOverlay.tsx
@@ -81,7 +81,7 @@ export const ViewportDebugOverlay: React.FC = () => {
 
   const visibleLegos = useVisibleLegoIds();
   const connectedLegos = useCanvasStore((state) => state.connectedLegos);
-  const connectedLegoIds = connectedLegos.map((c) => c.instanceId);
+  const connectedLegoIds = connectedLegos.map((c) => c.instance_id);
 
   const zoomLevel = viewport.zoomLevel;
 
diff --git a/app/ui/src/features/canvas/canvasCalculations.ts b/app/ui/src/features/canvas/canvasCalculations.ts
index 66f56874..e186ef72 100644
--- a/app/ui/src/features/canvas/canvasCalculations.ts
+++ b/app/ui/src/features/canvas/canvasCalculations.ts
@@ -52,13 +52,13 @@ export const findClosestConnection = (
 
   connections.forEach((conn) => {
     const fromLego = droppedLegos.find(
-      (l) => l.instanceId === conn.from.legoId
+      (l) => l.instance_id === conn.from.legoId
     );
-    const toLego = droppedLegos.find((l) => l.instanceId === conn.to.legoId);
+    const toLego = droppedLegos.find((l) => l.instance_id === conn.to.legoId);
     if (!fromLego || !toLego) return;
 
-    const fromPos = fromLego.style!.legStyles[conn.from.legIndex].position;
-    const toPos = toLego.style!.legStyles[conn.to.legIndex].position;
+    const fromPos = fromLego.style!.legStyles[conn.from.leg_index].position;
+    const toPos = toLego.style!.legStyles[conn.to.leg_index].position;
 
     // Connection positions are in logical canvas coordinates
     const fromPoint = new LogicalPoint(
@@ -94,24 +94,25 @@ export const findClosestDanglingLeg = (
   dropPosition: LogicalPoint,
   droppedLegos: DroppedLego[],
   connections: Connection[]
-): { lego: DroppedLego; legIndex: number; distance: number } | null => {
+): { lego: DroppedLego; leg_index: number; distance: number } | null => {
   let closestLego: DroppedLego | null = null;
   let closestLegIndex: number = -1;
   let minDistance = Infinity;
 
   droppedLegos.forEach((lego) => {
     const totalLegs = lego.numberOfLegs;
-    for (let legIndex = 0; legIndex < totalLegs; legIndex++) {
+    for (let leg_index = 0; leg_index < totalLegs; leg_index++) {
       // Skip if leg is already connected
       const isConnected = connections.some(
         (conn) =>
-          (conn.from.legoId === lego.instanceId &&
-            conn.from.legIndex === legIndex) ||
-          (conn.to.legoId === lego.instanceId && conn.to.legIndex === legIndex)
+          (conn.from.legoId === lego.instance_id &&
+            conn.from.leg_index === leg_index) ||
+          (conn.to.legoId === lego.instance_id &&
+            conn.to.leg_index === leg_index)
       );
       if (isConnected) continue;
 
-      const pos = lego.style!.legStyles[legIndex].position;
+      const pos = lego.style!.legStyles[leg_index].position;
       // Leg positions are in logical canvas coordinates
       const legX = lego.logicalPosition.x + pos.endX;
       const legY = lego.logicalPosition.y + pos.endY;
@@ -125,12 +126,12 @@ export const findClosestDanglingLeg = (
         // 20 pixels threshold
         minDistance = distance;
         closestLego = lego;
-        closestLegIndex = legIndex;
+        closestLegIndex = leg_index;
       }
     }
   });
 
   return closestLego && closestLegIndex !== -1
-    ? { lego: closestLego, legIndex: closestLegIndex, distance: minDistance }
+    ? { lego: closestLego, leg_index: closestLegIndex, distance: minDistance }
     : null;
 };
diff --git a/app/ui/src/features/details-panel/DetailsPanel.tsx b/app/ui/src/features/details-panel/DetailsPanel.tsx
index 6951995a..a2ac1aff 100644
--- a/app/ui/src/features/details-panel/DetailsPanel.tsx
+++ b/app/ui/src/features/details-panel/DetailsPanel.tsx
@@ -60,7 +60,7 @@ import {
 } from "../../config/supabaseClient.ts";
 import { Legos } from "../lego/Legos.ts";
 import { config, getApiUrl } from "../../config/config.ts";
-import { getAccessToken } from "../../lib/auth.ts";
+import { getAccessToken } from "../auth/auth.ts";
 import { useEffect } from "react";
 import TaskDetailsDisplay from "../tasks/TaskDetailsDisplay.tsx";
 import TaskLogsModal from "../tasks/TaskLogsModal.tsx";
@@ -166,14 +166,14 @@ const DetailsPanel: React.FC<DetailsPanelProps> = ({
       }
 
       const legOrdering = result.legs.map((leg) => ({
-        instanceId: leg.instanceId,
-        legIndex: leg.legIndex
+        instance_id: leg.instance_id,
+        leg_index: leg.leg_index
       }));
 
       // Update the tensor network with the new matrix and leg ordering
       setTensorNetwork(
         tensorNetwork.with({
-          parityCheckMatrix: result.h.getMatrix(),
+          parity_check_matrix: result.h.getMatrix(),
           legOrdering: legOrdering
         })
       );
@@ -328,16 +328,16 @@ const DetailsPanel: React.FC<DetailsPanelProps> = ({
         const updatedLego = new DroppedLego(
           lego,
           lego.logicalPosition,
-          lego.instanceId,
+          lego.instance_id,
           { selectedMatrixRows: selectedRows }
         );
 
-        updateDroppedLego(updatedLego.instanceId, updatedLego);
+        updateDroppedLego(updatedLego.instance_id, updatedLego);
 
         simpleAutoFlow(
           updatedLego,
           droppedLegos.map((lego) =>
-            lego.instanceId === updatedLego.instanceId ? updatedLego : lego
+            lego.instance_id === updatedLego.instance_id ? updatedLego : lego
           ),
           connections,
           setDroppedLegos
@@ -367,14 +367,14 @@ const DetailsPanel: React.FC<DetailsPanelProps> = ({
       const updatedLego = new DroppedLego(
         lego,
         lego.logicalPosition,
-        lego.instanceId,
+        lego.instance_id,
         { parity_check_matrix: newMatrix }
       );
-      updateDroppedLego(updatedLego.instanceId, updatedLego);
+      updateDroppedLego(updatedLego.instance_id, updatedLego);
       simpleAutoFlow(
         updatedLego,
         droppedLegos.map((lego) =>
-          lego.instanceId === updatedLego.instanceId ? updatedLego : lego
+          lego.instance_id === updatedLego.instance_id ? updatedLego : lego
         ),
         connections,
         setDroppedLegos
@@ -389,7 +389,7 @@ const DetailsPanel: React.FC<DetailsPanelProps> = ({
       if (!tensorNetwork) return;
 
       // Update the tensor network state
-      setTensorNetwork(tensorNetwork.with({ parityCheckMatrix: newMatrix }));
+      setTensorNetwork(tensorNetwork.with({ parity_check_matrix: newMatrix }));
 
       // Update the cache
       const signature = tensorNetwork.signature!;
@@ -414,27 +414,27 @@ const DetailsPanel: React.FC<DetailsPanelProps> = ({
         length: tensorNetwork.legos[0].numberOfLegs
       },
       (_, i) => ({
-        instanceId: tensorNetwork.legos[0].instanceId,
-        legIndex: i
+        instance_id: tensorNetwork.legos[0].instance_id,
+        leg_index: i
       })
     );
   }, [
-    tensorNetwork?.legos?.[0]?.instanceId,
+    tensorNetwork?.legos?.[0]?.instance_id,
     tensorNetwork?.legos?.[0]?.parity_check_matrix?.length
   ]);
 
   const handleChangeColor = (lego: DroppedLego) => {
     // Get max instance ID
     const maxInstanceId = Math.max(
-      ...droppedLegos.map((l) => parseInt(l.instanceId))
+      ...droppedLegos.map((l) => parseInt(l.instance_id))
     );
     const numLegs = lego.numberOfLegs;
 
     // Find any existing connections to the original lego
     const existingConnections = connections.filter(
       (conn) =>
-        conn.from.legoId === lego.instanceId ||
-        conn.to.legoId === lego.instanceId
+        conn.from.legoId === lego.instance_id ||
+        conn.to.legoId === lego.instance_id
     );
 
     // Store the old state for history
@@ -448,7 +448,7 @@ const DetailsPanel: React.FC<DetailsPanelProps> = ({
     const newLegos: DroppedLego[] = [
       lego.with({
         type_id: lego.type_id === "x_rep_code" ? "z_rep_code" : "x_rep_code",
-        shortName: lego.type_id === "x_rep_code" ? "Z Rep Code" : "X Rep Code",
+        short_name: lego.type_id === "x_rep_code" ? "Z Rep Code" : "X Rep Code",
         parity_check_matrix: newParityCheckMatrix
       })
     ];
@@ -481,29 +481,29 @@ const DetailsPanel: React.FC<DetailsPanelProps> = ({
       // Connect Hadamard to the original lego
       newConnections.push(
         new Connection(
-          { legoId: lego.instanceId, legIndex: i },
-          { legoId: hadamardLego.instanceId, legIndex: 0 }
+          { legoId: lego.instance_id, leg_index: i },
+          { legoId: hadamardLego.instance_id, leg_index: 0 }
         )
       );
 
       // Connect Hadamard to the original connection if it exists
       const existingConnection = existingConnections.find((conn) =>
-        conn.containsLeg(lego.instanceId, i)
+        conn.containsLeg(lego.instance_id, i)
       );
 
       if (existingConnection) {
-        if (existingConnection.from.legoId === lego.instanceId) {
+        if (existingConnection.from.legoId === lego.instance_id) {
           newConnections.push(
             new Connection(
-              { legoId: hadamardLego.instanceId, legIndex: 1 },
+              { legoId: hadamardLego.instance_id, leg_index: 1 },
               existingConnection.to
             )
           );
         } else {
           newConnections.push(
             new Connection(existingConnection.from, {
-              legoId: hadamardLego.instanceId,
-              legIndex: 1
+              legoId: hadamardLego.instance_id,
+              leg_index: 1
             })
           );
         }
@@ -512,7 +512,7 @@ const DetailsPanel: React.FC<DetailsPanelProps> = ({
 
     // Update state with the legos that were pushed out of the way
     const finalLegos = [
-      ...updatedLegos.filter((l) => l.instanceId !== lego.instanceId),
+      ...updatedLegos.filter((l) => l.instance_id !== lego.instance_id),
       ...newLegos
     ];
     const updatedConnections = [
@@ -521,9 +521,9 @@ const DetailsPanel: React.FC<DetailsPanelProps> = ({
           !existingConnections.some(
             (existingConn) =>
               existingConn.from.legoId === conn.from.legoId &&
-              existingConn.from.legIndex === conn.from.legIndex &&
+              existingConn.from.leg_index === conn.from.leg_index &&
               existingConn.to.legoId === conn.to.legoId &&
-              existingConn.to.legIndex === conn.to.legIndex
+              existingConn.to.leg_index === conn.to.leg_index
           )
       ),
       ...newConnections
@@ -551,7 +551,7 @@ const DetailsPanel: React.FC<DetailsPanelProps> = ({
     const updatedLego = lego.with({ alwaysShowLegs: true });
     setDroppedLegos(
       droppedLegos.map((l) =>
-        l.instanceId === lego.instanceId ? updatedLego : l
+        l.instance_id === lego.instance_id ? updatedLego : l
       )
     );
     setUnfuseLego(updatedLego);
@@ -561,7 +561,7 @@ const DetailsPanel: React.FC<DetailsPanelProps> = ({
     const cleanup = () => {
       setDroppedLegos(
         droppedLegos.map((l) =>
-          l.instanceId === lego.instanceId
+          l.instance_id === lego.instance_id
             ? l.with({ alwaysShowLegs: originalAlwaysShowLegs })
             : l
         )
@@ -586,13 +586,13 @@ const DetailsPanel: React.FC<DetailsPanelProps> = ({
 
     // Get max instance ID
     const maxInstanceId = Math.max(
-      ...droppedLegos.map((l) => parseInt(l.instanceId))
+      ...droppedLegos.map((l) => parseInt(l.instance_id))
     );
 
     // Find any existing connections to the original lego
     console.log("Old connections", oldConnections);
     const connectionsInvolvingLego = oldConnections.filter((conn) =>
-      conn.containsLego(lego.instanceId)
+      conn.containsLego(lego.instance_id)
     );
 
     try {
@@ -652,12 +652,12 @@ const DetailsPanel: React.FC<DetailsPanelProps> = ({
       // Create connection between the new legos
       const connectionBetweenLegos: Connection = new Connection(
         {
-          legoId: lego1.instanceId,
-          legIndex: lego1Legs // The last leg is the connecting one
+          legoId: lego1.instance_id,
+          leg_index: lego1Legs // The last leg is the connecting one
         },
         {
-          legoId: lego2.instanceId,
-          legIndex: lego2Legs // The last leg is the connecting one
+          legoId: lego2.instance_id,
+          leg_index: lego2Legs // The last leg is the connecting one
         }
       );
 
@@ -667,28 +667,28 @@ const DetailsPanel: React.FC<DetailsPanelProps> = ({
           _.cloneDeep(conn.from),
           _.cloneDeep(conn.to)
         );
-        if (conn.from.legoId === lego.instanceId) {
-          const oldLegIndex = conn.from.legIndex;
+        if (conn.from.legoId === lego.instance_id) {
+          const oldLegIndex = conn.from.leg_index;
           if (!legPartition[oldLegIndex]) {
             // Goes to lego1
-            newConn.from.legoId = lego1.instanceId;
-            newConn.from.legIndex = lego1LegMap.get(oldLegIndex)!;
+            newConn.from.legoId = lego1.instance_id;
+            newConn.from.leg_index = lego1LegMap.get(oldLegIndex)!;
           } else {
             // Goes to lego2
-            newConn.from.legoId = lego2.instanceId;
-            newConn.from.legIndex = lego2LegMap.get(oldLegIndex)!;
+            newConn.from.legoId = lego2.instance_id;
+            newConn.from.leg_index = lego2LegMap.get(oldLegIndex)!;
           }
         }
-        if (conn.to.legoId === lego.instanceId) {
-          const oldLegIndex = conn.to.legIndex;
+        if (conn.to.legoId === lego.instance_id) {
+          const oldLegIndex = conn.to.leg_index;
           if (!legPartition[oldLegIndex]) {
             // Goes to lego1
-            newConn.to.legoId = lego1.instanceId;
-            newConn.to.legIndex = lego1LegMap.get(oldLegIndex)!;
+            newConn.to.legoId = lego1.instance_id;
+            newConn.to.leg_index = lego1LegMap.get(oldLegIndex)!;
           } else {
             // Goes to lego2
-            newConn.to.legoId = lego2.instanceId;
-            newConn.to.legIndex = lego2LegMap.get(oldLegIndex)!;
+            newConn.to.legoId = lego2.instance_id;
+            newConn.to.leg_index = lego2LegMap.get(oldLegIndex)!;
           }
         }
         return newConn;
@@ -696,7 +696,7 @@ const DetailsPanel: React.FC<DetailsPanelProps> = ({
 
       // Update the state
       const newLegos = [
-        ...droppedLegos.filter((l) => l.instanceId !== lego.instanceId),
+        ...droppedLegos.filter((l) => l.instance_id !== lego.instance_id),
         lego1,
         lego2
       ];
@@ -704,7 +704,7 @@ const DetailsPanel: React.FC<DetailsPanelProps> = ({
       // Only keep connections that don't involve the original lego at all
       // We need to filter from the full connections array, not just existingConnections
       const remainingConnections = oldConnections.filter(
-        (c) => !c.containsLego(lego.instanceId)
+        (c) => !c.containsLego(lego.instance_id)
       );
 
       // Add the remapped connections and the new connection between legos
@@ -743,15 +743,15 @@ const DetailsPanel: React.FC<DetailsPanelProps> = ({
   const handleUnfuseToLegs = (lego: DroppedLego) => {
     // Get max instance ID
     const maxInstanceId = Math.max(
-      ...droppedLegos.map((l) => parseInt(l.instanceId))
+      ...droppedLegos.map((l) => parseInt(l.instance_id))
     );
     const numLegs = lego.numberOfLegs;
 
     // Find any existing connections to the original lego
     const existingConnections = connections.filter(
       (conn) =>
-        conn.from.legoId === lego.instanceId ||
-        conn.to.legoId === lego.instanceId
+        conn.from.legoId === lego.instance_id ||
+        conn.to.legoId === lego.instance_id
     );
 
     let newLegos: DroppedLego[] = [];
@@ -782,7 +782,7 @@ const DetailsPanel: React.FC<DetailsPanelProps> = ({
     if (numLegs === 1) {
       // Case 1: Original lego has 1 leg -> Create 1 new lego with 2 legs
       const newLego: DroppedLego = lego.with({
-        instanceId: (maxInstanceId + 1).toString(),
+        instance_id: (maxInstanceId + 1).toString(),
         logicalPosition: lego.logicalPosition.plus(new LogicalPoint(100, 0)),
         selectedMatrixRows: [],
         parity_check_matrix: bell_pair
@@ -792,26 +792,26 @@ const DetailsPanel: React.FC<DetailsPanelProps> = ({
       // Connect the new lego to the original connections
       if (existingConnections.length > 0) {
         const firstConnection = existingConnections[0];
-        if (firstConnection.from.legoId === lego.instanceId) {
+        if (firstConnection.from.legoId === lego.instance_id) {
           newConnections = [
             new Connection(
-              { legoId: newLego.instanceId, legIndex: 0 },
+              { legoId: newLego.instance_id, leg_index: 0 },
               firstConnection.to
             ),
             new Connection(
-              { legoId: newLego.instanceId, legIndex: 1 },
-              { legoId: lego.instanceId, legIndex: 1 }
+              { legoId: newLego.instance_id, leg_index: 1 },
+              { legoId: lego.instance_id, leg_index: 1 }
             )
           ];
         } else {
           newConnections = [
             new Connection(firstConnection.from, {
-              legoId: newLego.instanceId,
-              legIndex: 0
+              legoId: newLego.instance_id,
+              leg_index: 0
             }),
             new Connection(
-              { legoId: lego.instanceId, legIndex: 1 },
-              { legoId: newLego.instanceId, legIndex: 1 }
+              { legoId: lego.instance_id, leg_index: 1 },
+              { legoId: newLego.instance_id, leg_index: 1 }
             )
           ];
         }
@@ -819,7 +819,7 @@ const DetailsPanel: React.FC<DetailsPanelProps> = ({
     } else if (numLegs === 2) {
       // Case 2: Original lego has 2 legs -> Create 1 new lego with 2 legs
       const newLego: DroppedLego = lego.with({
-        instanceId: (maxInstanceId + 1).toString(),
+        instance_id: (maxInstanceId + 1).toString(),
         logicalPosition: lego.logicalPosition.plus(new LogicalPoint(100, 0)),
         selectedMatrixRows: [],
         parity_check_matrix: bell_pair
@@ -830,24 +830,24 @@ const DetailsPanel: React.FC<DetailsPanelProps> = ({
 
       newConnections.push(
         new Connection(
-          { legoId: newLego.instanceId, legIndex: 0 },
-          { legoId: lego.instanceId, legIndex: 1 }
+          { legoId: newLego.instance_id, leg_index: 0 },
+          { legoId: lego.instance_id, leg_index: 1 }
         )
       );
 
       // Connect the new lego to the original connections
       existingConnections.forEach((conn, index) => {
         const targetLego = index === 0 ? lego : newLego;
-        const legIndex = index === 0 ? 0 : 1;
+        const leg_index = index === 0 ? 0 : 1;
 
         newConnections.push(
           new Connection(
-            conn.from.legoId === lego.instanceId
-              ? { legoId: targetLego.instanceId, legIndex }
+            conn.from.legoId === lego.instance_id
+              ? { legoId: targetLego.instance_id, leg_index }
               : conn.from,
-            conn.from.legoId === lego.instanceId
+            conn.from.legoId === lego.instance_id
               ? conn.to
-              : { legoId: targetLego.instanceId, legIndex }
+              : { legoId: targetLego.instance_id, leg_index }
           )
         );
       });
@@ -863,7 +863,7 @@ const DetailsPanel: React.FC<DetailsPanelProps> = ({
       for (let i = 0; i < numLegs; i++) {
         const angle = (2 * Math.PI * i) / numLegs;
         const newLego: DroppedLego = lego.with({
-          instanceId: (maxInstanceId + 1 + i).toString(),
+          instance_id: (maxInstanceId + 1 + i).toString(),
           logicalPosition: center.plus(
             new LogicalPoint(radius * Math.cos(angle), radius * Math.sin(angle))
           ),
@@ -879,26 +879,26 @@ const DetailsPanel: React.FC<DetailsPanelProps> = ({
         const nextIndex = (i + 1) % numLegs;
         newConnections.push(
           new Connection(
-            { legoId: newLegos[i].instanceId, legIndex: 0 },
-            { legoId: newLegos[nextIndex].instanceId, legIndex: 1 }
+            { legoId: newLegos[i].instance_id, leg_index: 0 },
+            { legoId: newLegos[nextIndex].instance_id, leg_index: 1 }
           )
         );
 
         // Connect the third leg (leg 2) to the original connections
         if (existingConnections[i]) {
           const conn = existingConnections[i];
-          if (conn.from.legoId === lego.instanceId) {
+          if (conn.from.legoId === lego.instance_id) {
             newConnections.push(
               new Connection(
-                { legoId: newLegos[i].instanceId, legIndex: 2 },
+                { legoId: newLegos[i].instance_id, leg_index: 2 },
                 conn.to
               )
             );
           } else {
             newConnections.push(
               new Connection(conn.from, {
-                legoId: newLegos[i].instanceId,
-                legIndex: 2
+                legoId: newLegos[i].instance_id,
+                leg_index: 2
               })
             );
           }
@@ -908,7 +908,7 @@ const DetailsPanel: React.FC<DetailsPanelProps> = ({
 
     // Update state
     const updatedLegos = [
-      ...droppedLegos.filter((l) => l.instanceId !== lego.instanceId),
+      ...droppedLegos.filter((l) => l.instance_id !== lego.instance_id),
       ...newLegos
     ];
     const updatedConnections = [
@@ -917,9 +917,9 @@ const DetailsPanel: React.FC<DetailsPanelProps> = ({
           !existingConnections.some(
             (existingConn) =>
               existingConn.from.legoId === conn.from.legoId &&
-              existingConn.from.legIndex === conn.from.legIndex &&
+              existingConn.from.leg_index === conn.from.leg_index &&
               existingConn.to.legoId === conn.to.legoId &&
-              existingConn.to.legIndex === conn.to.legIndex
+              existingConn.to.leg_index === conn.to.leg_index
           )
       ),
       ...newConnections
@@ -1113,11 +1113,11 @@ const DetailsPanel: React.FC<DetailsPanelProps> = ({
             <VStack align="stretch" spacing={3}>
               <Text fontWeight="bold">
                 {tensorNetwork.legos[0].name ||
-                  tensorNetwork.legos[0].shortName}
+                  tensorNetwork.legos[0].short_name}
               </Text>
               <Text fontSize="sm" color="gray.600">
                 {tensorNetwork.legos[0].description}, instaceId:{" "}
-                {tensorNetwork.legos[0].instanceId}, x:{" "}
+                {tensorNetwork.legos[0].instance_id}, x:{" "}
                 {tensorNetwork.legos[0].logicalPosition.x}, y:{" "}
                 {tensorNetwork.legos[0].logicalPosition.y}
               </Text>
@@ -1127,15 +1127,15 @@ const DetailsPanel: React.FC<DetailsPanelProps> = ({
                 </Text>
                 <Input
                   size="sm"
-                  value={tensorNetwork.legos[0].shortName}
+                  value={tensorNetwork.legos[0].short_name}
                   onChange={(e) => {
                     const newShortName = e.target.value;
                     const updatedLego = tensorNetwork.legos[0].with({
-                      shortName: newShortName
+                      short_name: newShortName
                     });
                     setTimeout(() => {
                       updateDroppedLego(
-                        tensorNetwork.legos[0].instanceId,
+                        tensorNetwork.legos[0].instance_id,
                         updatedLego
                       );
                     });
@@ -1153,7 +1153,7 @@ const DetailsPanel: React.FC<DetailsPanelProps> = ({
                       alwaysShowLegs: e.target.checked
                     });
                     updateDroppedLego(
-                      tensorNetwork.legos[0].instanceId,
+                      tensorNetwork.legos[0].instance_id,
                       updatedLego
                     );
                   }}
@@ -1284,7 +1284,7 @@ const DetailsPanel: React.FC<DetailsPanelProps> = ({
                 </VStack>
                 <Heading size="md">Network Details</Heading>
                 <VStack align="stretch" spacing={3}>
-                  {!tensorNetwork.parityCheckMatrix &&
+                  {!tensorNetwork.parity_check_matrix &&
                     !parityCheckMatrixCache.get(tensorNetwork.signature!) && (
                       <Button
                         onClick={calculateParityCheckMatrix}
@@ -1296,14 +1296,14 @@ const DetailsPanel: React.FC<DetailsPanelProps> = ({
                         Calculate Parity Check Matrix
                       </Button>
                     )}
-                  {(tensorNetwork.parityCheckMatrix ||
+                  {(tensorNetwork.parity_check_matrix ||
                     (tensorNetwork &&
                       parityCheckMatrixCache.get(
                         tensorNetwork.signature!
                       ))) && (
                     <ParityCheckMatrixDisplay
                       matrix={
-                        tensorNetwork.parityCheckMatrix ||
+                        tensorNetwork.parity_check_matrix ||
                         parityCheckMatrixCache.get(tensorNetwork.signature!)!
                           .matrix
                       }
diff --git a/app/ui/src/features/details-panel/LegReorderDialog.tsx b/app/ui/src/features/details-panel/LegReorderDialog.tsx
index 8e299946..4db8a8f4 100644
--- a/app/ui/src/features/details-panel/LegReorderDialog.tsx
+++ b/app/ui/src/features/details-panel/LegReorderDialog.tsx
@@ -90,7 +90,7 @@ export const LegReorderDialog: React.FC<LegReorderDialogProps> = ({
                   <Box flex={1}>
                     <Text fontWeight="bold">Leg {index}</Text>
                     <Text fontSize="sm" color="gray.600">
-                      {leg.instanceId}:{leg.legIndex}
+                      {leg.instance_id}:{leg.leg_index}
                     </Text>
                   </Box>
                   <HStack spacing={1}>
diff --git a/app/ui/src/features/details-panel/ParityCheckMatrixDisplay.tsx b/app/ui/src/features/details-panel/ParityCheckMatrixDisplay.tsx
index 77f316e1..9686e03d 100644
--- a/app/ui/src/features/details-panel/ParityCheckMatrixDisplay.tsx
+++ b/app/ui/src/features/details-panel/ParityCheckMatrixDisplay.tsx
@@ -650,8 +650,8 @@ export const ParityCheckMatrixDisplay: React.FC<
             {legOrdering && legOrdering[hoveredLegIndex] && (
               <>
                 {" "}
-                • <b>Tensor:</b> {legOrdering[hoveredLegIndex].instanceId} •{" "}
-                <b>Leg:</b> {legOrdering[hoveredLegIndex].legIndex}
+                • <b>Tensor:</b> {legOrdering[hoveredLegIndex].instance_id} •{" "}
+                <b>Leg:</b> {legOrdering[hoveredLegIndex].leg_index}
               </>
             )}
           </Text>
diff --git a/app/ui/src/features/details-panel/StabilizerGraphView.tsx b/app/ui/src/features/details-panel/StabilizerGraphView.tsx
index 5cc80398..71089858 100644
--- a/app/ui/src/features/details-panel/StabilizerGraphView.tsx
+++ b/app/ui/src/features/details-panel/StabilizerGraphView.tsx
@@ -21,7 +21,7 @@ interface SimulationNode extends d3.SimulationNodeDatum {
   isStabilizer: boolean;
   stabilizerIndex?: number;
   type?: "X" | "Z";
-  legIndex?: number;
+  leg_index?: number;
 }
 
 interface SimulationLink extends d3.SimulationLinkDatum<SimulationNode> {
@@ -77,8 +77,8 @@ export const StabilizerGraphView: React.FC<StabilizerGraphViewProps> = ({
       if (!stabilizerPoint) return;
 
       const stabilizerLegs = getStabilizerLegs(row);
-      stabilizerLegs.forEach((legIndex) => {
-        const legPoint = points[matrix.length + legIndex];
+      stabilizerLegs.forEach((leg_index) => {
+        const legPoint = points[matrix.length + leg_index];
         if (!legPoint || legPoint.isStabilizer) return;
 
         // Draw connection line
@@ -125,8 +125,8 @@ export const StabilizerGraphView: React.FC<StabilizerGraphViewProps> = ({
         ctx.fillText(point.stabilizerIndex!.toString(), point.x, point.y);
       } else {
         // Draw leg circle
-        const legIndex = index - matrix.length;
-        if (legIndex >= 0 && legIndex < legs.length) {
+        const leg_index = index - matrix.length;
+        if (leg_index >= 0 && leg_index < legs.length) {
           ctx.beginPath();
           ctx.arc(point.x, point.y, 20, 0, 2 * Math.PI);
           ctx.fillStyle = selectedPoints.has(index) ? "#e2e8f0" : "white";
@@ -141,7 +141,7 @@ export const StabilizerGraphView: React.FC<StabilizerGraphViewProps> = ({
           ctx.textAlign = "center";
           ctx.textBaseline = "middle";
           ctx.fillText(
-            `${legs[legIndex].instanceId}-${legs[legIndex].legIndex}`,
+            `${legs[leg_index].instance_id}-${legs[leg_index].leg_index}`,
             point.x,
             point.y
           );
@@ -161,7 +161,7 @@ export const StabilizerGraphView: React.FC<StabilizerGraphViewProps> = ({
       isStabilizer: point.isStabilizer ?? false,
       stabilizerIndex: point.stabilizerIndex,
       type: point.type,
-      legIndex: (point as unknown as { legIndex: number }).legIndex
+      leg_index: (point as unknown as { leg_index: number }).leg_index
     }));
 
     // Create links between stabilizers and legs
@@ -170,10 +170,10 @@ export const StabilizerGraphView: React.FC<StabilizerGraphViewProps> = ({
       const stabilizerLegs = getStabilizerLegs(row);
       const stabilizerWeight = stabilizerLegs.length;
 
-      stabilizerLegs.forEach((legIndex) => {
+      stabilizerLegs.forEach((leg_index) => {
         links.push({
           source: stabilizerIndex,
-          target: matrix.length + legIndex,
+          target: matrix.length + leg_index,
           weight: stabilizerWeight
         });
       });
@@ -302,7 +302,7 @@ export const StabilizerGraphView: React.FC<StabilizerGraphViewProps> = ({
         isStabilizer: false,
         stabilizerIndex: undefined,
         type: undefined as "X" | "Z" | undefined,
-        legIndex: index
+        leg_index: index
       };
     });
 
diff --git a/app/ui/src/features/lego/ConnectionsLayer.tsx b/app/ui/src/features/lego/ConnectionsLayer.tsx
index 47dd5363..dc8fb0b3 100644
--- a/app/ui/src/features/lego/ConnectionsLayer.tsx
+++ b/app/ui/src/features/lego/ConnectionsLayer.tsx
@@ -43,7 +43,7 @@ export const ConnectionsLayer: React.FC = () => {
   // Memoize lego lookup map for performance
   const legoMap = useMemo(() => {
     const map = new Map<string, DroppedLego>();
-    connectedLegos.forEach((lego) => map.set(lego.instanceId, lego));
+    connectedLegos.forEach((lego) => map.set(lego.instance_id, lego));
     return map;
   }, [connectedLegos]);
 
@@ -51,8 +51,8 @@ export const ConnectionsLayer: React.FC = () => {
   const connectedLegsMap = useMemo(() => {
     const map = new Map<string, boolean>();
     connections.forEach((conn) => {
-      map.set(`${conn.from.legoId}-${conn.from.legIndex}`, true);
-      map.set(`${conn.to.legoId}-${conn.to.legIndex}`, true);
+      map.set(`${conn.from.legoId}-${conn.from.leg_index}`, true);
+      map.set(`${conn.to.legoId}-${conn.to.leg_index}`, true);
     });
     return map;
   }, [connections]);
@@ -68,7 +68,7 @@ export const ConnectionsLayer: React.FC = () => {
       for (let i = 0; i < numLegs; i++) {
         const legStyle = lego.style!.legStyles[i];
         const legColor = lego.style!.getLegColor(i);
-        map.set(`${lego.instanceId}-${i}`, {
+        map.set(`${lego.instance_id}-${i}`, {
           style: legStyle,
           color: legColor,
           isHighlighted: legStyle.is_highlighted
@@ -84,9 +84,9 @@ export const ConnectionsLayer: React.FC = () => {
       return !!(
         hoveredConnection &&
         hoveredConnection.from.legoId === conn.from.legoId &&
-        hoveredConnection.from.legIndex === conn.from.legIndex &&
+        hoveredConnection.from.leg_index === conn.from.leg_index &&
         hoveredConnection.to.legoId === conn.to.legoId &&
-        hoveredConnection.to.legIndex === conn.to.legIndex
+        hoveredConnection.to.leg_index === conn.to.leg_index
       );
     },
     [hoveredConnection]
@@ -106,35 +106,35 @@ export const ConnectionsLayer: React.FC = () => {
           conn.from.legoId < conn.to.legoId
             ? [
                 conn.from.legoId,
-                conn.from.legIndex,
+                conn.from.leg_index,
                 conn.to.legoId,
-                conn.to.legIndex
+                conn.to.leg_index
               ]
             : [
                 conn.to.legoId,
-                conn.to.legIndex,
+                conn.to.leg_index,
                 conn.from.legoId,
-                conn.from.legIndex
+                conn.from.leg_index
               ];
         const connKey = `${firstId}-${firstLeg}-${secondId}-${secondLeg}`;
 
-        const fromPos = fromLego.style!.legStyles[conn.from.legIndex].position;
-        const toPos = toLego.style!.legStyles[conn.to.legIndex].position;
+        const fromPos = fromLego.style!.legStyles[conn.from.leg_index].position;
+        const toPos = toLego.style!.legStyles[conn.to.leg_index].position;
 
         // Use pre-computed maps for O(1) lookup
         const fromLegConnected = connectedLegsMap.has(
-          `${fromLego.instanceId}-${conn.from.legIndex}`
+          `${fromLego.instance_id}-${conn.from.leg_index}`
         );
         const toLegConnected = connectedLegsMap.has(
-          `${toLego.instanceId}-${conn.to.legIndex}`
+          `${toLego.instance_id}-${conn.to.leg_index}`
         );
 
         // Get pre-computed leg styles
         const fromLegData = legStylesMap.get(
-          `${fromLego.instanceId}-${conn.from.legIndex}`
+          `${fromLego.instance_id}-${conn.from.leg_index}`
         );
         const toLegData = legStylesMap.get(
-          `${toLego.instanceId}-${conn.to.legIndex}`
+          `${toLego.instance_id}-${conn.to.leg_index}`
         );
 
         if (!fromLegData || !toLegData) return null;
@@ -309,7 +309,7 @@ export const ConnectionsLayer: React.FC = () => {
     if (!fromLego) return null;
 
     // Calculate position using shared function with smart scaling
-    const fromPos = fromLego.style!.legStyles[legDragState.legIndex].position;
+    const fromPos = fromLego.style!.legStyles[legDragState.leg_index].position;
     // Calculate scale factor for smart sizing
     const fromBasePoint = new LogicalPoint(
       fromLego.logicalPosition.x,
@@ -326,7 +326,7 @@ export const ConnectionsLayer: React.FC = () => {
       legDragState.currentMouseWindowPoint
     );
 
-    const legStyle = fromLego.style!.legStyles[legDragState.legIndex];
+    const legStyle = fromLego.style!.legStyles[legDragState.leg_index];
     const baseControlPointDistance = 30;
     const controlPointDistance =
       baseControlPointDistance * Math.min(1, zoomLevel * 0.8 + 0.2);
diff --git a/app/ui/src/features/lego/DragProxy.tsx b/app/ui/src/features/lego/DragProxy.tsx
index 9d6e85dd..f26d9cfd 100644
--- a/app/ui/src/features/lego/DragProxy.tsx
+++ b/app/ui/src/features/lego/DragProxy.tsx
@@ -23,7 +23,7 @@ const SingleLegoDragProxy: React.FC<{
     if (!legoDragState || legoDragState.draggedLegoInstanceId === "")
       return null;
     return droppedLegos.find(
-      (lego) => lego.instanceId === legoDragState.draggedLegoInstanceId
+      (lego) => lego.instance_id === legoDragState.draggedLegoInstanceId
     );
   }, [droppedLegos, legoDragState]);
 
@@ -45,7 +45,7 @@ const SingleLegoDragProxy: React.FC<{
 
   return (
     <div
-      key={`single-drag-proxy-${draggedLego.instanceId}`}
+      key={`single-drag-proxy-${draggedLego.instance_id}`}
       style={{
         position: "absolute",
         left: `${proxyCanvasPos.x - smartSize / 2}px`,
@@ -107,7 +107,7 @@ const GroupDragProxy: React.FC<{
   const draggedLegos = useMemo(() => {
     if (!groupDragState) return [];
     return droppedLegos.filter((lego) =>
-      groupDragState.legoInstanceIds.includes(lego.instanceId)
+      groupDragState.legoInstanceIds.includes(lego.instance_id)
     );
   }, [droppedLegos, groupDragState]);
 
@@ -132,7 +132,7 @@ const GroupDragProxy: React.FC<{
   return (
     <>
       {draggedLegos.map((lego: DroppedLego) => {
-        const originalPos = groupDragState.originalPositions[lego.instanceId];
+        const originalPos = groupDragState.originalPositions[lego.instance_id];
         if (!originalPos) return null; // Safety check for stale state
 
         // Calculate base proxy position in canvas coordinates
@@ -147,7 +147,7 @@ const GroupDragProxy: React.FC<{
 
         return (
           <div
-            key={`group-drag-proxy-${lego.instanceId}`}
+            key={`group-drag-proxy-${lego.instance_id}`}
             style={{
               position: "absolute",
               left: `${proxyCanvasPos.x - smartSize / 2}px`,
diff --git a/app/ui/src/features/lego/DroppedLegoDisplay.tsx b/app/ui/src/features/lego/DroppedLegoDisplay.tsx
index 7b2517c1..1b6d4cb7 100644
--- a/app/ui/src/features/lego/DroppedLegoDisplay.tsx
+++ b/app/ui/src/features/lego/DroppedLegoDisplay.tsx
@@ -77,10 +77,10 @@ const StaticLegsLayer = memo<{
   return (
     <>
       {/* Static leg lines - rendered first, conditionally hidden */}
-      {legStyles.map((legStyle, legIndex) =>
-        shouldHideLeg[legIndex] ? null : (
+      {legStyles.map((legStyle, leg_index) =>
+        shouldHideLeg[leg_index] ? null : (
           <line
-            key={`static-leg-${legIndex}`}
+            key={`static-leg-${leg_index}`}
             x1={legStyle.position.startX}
             y1={legStyle.position.startY}
             x2={legStyle.position.endX}
@@ -218,7 +218,7 @@ export const DroppedLegoDisplay: React.FC<DroppedLegoDisplayProps> = memo(
   ({ legoInstanceId, demoMode = false }) => {
     const lego = useCanvasStore(
       (state) =>
-        state.droppedLegos.find((l) => l.instanceId === legoInstanceId)!
+        state.droppedLegos.find((l) => l.instance_id === legoInstanceId)!
     );
 
     const canvasRef = useCanvasStore((state) => state.canvasRef);
@@ -246,14 +246,14 @@ export const DroppedLegoDisplay: React.FC<DroppedLegoDisplayProps> = memo(
 
     const legConnectionStates = useCanvasStore(
       useShallow((state) =>
-        lego ? state.legConnectionStates[lego.instanceId] || [] : []
+        lego ? state.legConnectionStates[lego.instance_id] || [] : []
       )
     );
 
     // Optimize store subscriptions to prevent unnecessary rerenders
     const legoConnections = useCanvasStore(
       useShallow((state) =>
-        lego ? state.legoConnectionMap[lego.instanceId] || [] : []
+        lego ? state.legoConnectionMap[lego.instance_id] || [] : []
       )
     );
 
@@ -265,10 +265,10 @@ export const DroppedLegoDisplay: React.FC<DroppedLegoDisplayProps> = memo(
     const isThisLegoBeingDragged = useCanvasStore((state) => {
       if (state.legoDragState.draggedLegoInstanceId === "") return false;
       const draggedLego = state.droppedLegos.find(
-        (l) => l.instanceId === state.legoDragState.draggedLegoInstanceId
+        (l) => l.instance_id === state.legoDragState.draggedLegoInstanceId
       );
       return (
-        draggedLego?.instanceId === lego.instanceId &&
+        draggedLego?.instance_id === lego.instance_id &&
         state.legoDragState.draggingStage === DraggingStage.DRAGGING
       );
     });
@@ -278,7 +278,7 @@ export const DroppedLegoDisplay: React.FC<DroppedLegoDisplayProps> = memo(
       return (
         (lego &&
           state.tensorNetwork?.legos.some(
-            (l) => l.instanceId === lego.instanceId
+            (l) => l.instance_id === lego.instance_id
           )) ||
         false
       );
@@ -286,7 +286,7 @@ export const DroppedLegoDisplay: React.FC<DroppedLegoDisplayProps> = memo(
 
     const legHiddenStates = useCanvasStore(
       useShallow((state) =>
-        lego ? state.legHideStates[lego.instanceId] || [] : []
+        lego ? state.legHideStates[lego.instance_id] || [] : []
       )
     );
 
@@ -329,15 +329,15 @@ export const DroppedLegoDisplay: React.FC<DroppedLegoDisplayProps> = memo(
         conn.from.legoId < conn.to.legoId
           ? [
               conn.from.legoId,
-              conn.from.legIndex,
+              conn.from.leg_index,
               conn.to.legoId,
-              conn.to.legIndex
+              conn.to.leg_index
             ]
           : [
               conn.to.legoId,
-              conn.to.legIndex,
+              conn.to.leg_index,
               conn.from.legoId,
-              conn.from.legIndex
+              conn.from.leg_index
             ];
       return `${firstId}-${firstLeg}-${secondId}-${secondLeg}`;
     };
@@ -345,7 +345,7 @@ export const DroppedLegoDisplay: React.FC<DroppedLegoDisplayProps> = memo(
     const handleLegMouseDown = (
       e: React.MouseEvent,
       legoId: string,
-      legIndex: number
+      leg_index: number
     ) => {
       if (!canvasRef) return;
 
@@ -354,18 +354,18 @@ export const DroppedLegoDisplay: React.FC<DroppedLegoDisplayProps> = memo(
 
       storeHandleLegMouseDown(
         legoId,
-        legIndex,
+        leg_index,
         WindowPoint.fromMouseEvent(e as unknown as MouseEvent)
       );
     };
 
-    const handleLegClick = (legoId: string, legIndex: number) => {
-      storeHandleLegClick(legoId, legIndex);
+    const handleLegClick = (legoId: string, leg_index: number) => {
+      storeHandleLegClick(legoId, leg_index);
     };
 
     const handleLegMouseUp = (e: React.MouseEvent, i: number) => {
       e.stopPropagation();
-      storeHandleLegMouseUp(lego.instanceId, i);
+      storeHandleLegMouseUp(lego.instance_id, i);
     };
 
     const isScalarLego = (lego: DroppedLego) => {
@@ -383,7 +383,7 @@ export const DroppedLegoDisplay: React.FC<DroppedLegoDisplayProps> = memo(
       e.preventDefault();
       e.stopPropagation();
       storeHandleLegoMouseDown(
-        lego.instanceId,
+        lego.instance_id,
         e.clientX,
         e.clientY,
         e.shiftKey
@@ -466,16 +466,16 @@ export const DroppedLegoDisplay: React.FC<DroppedLegoDisplayProps> = memo(
 
                 {/* Layer 2: Dynamic leg highlights (colored lines behind lego body) - with LOD */}
                 {lod.showLegs &&
-                  lego.style!.legStyles.map((legStyle, legIndex) => {
-                    const legColor = lego.style!.getLegColor(legIndex);
-                    const shouldHide = legHiddenStates[legIndex];
+                  lego.style!.legStyles.map((legStyle, leg_index) => {
+                    const legColor = lego.style!.getLegColor(leg_index);
+                    const shouldHide = legHiddenStates[leg_index];
 
                     if (legColor === "#A0AEC0" || shouldHide) {
                       return null;
                     }
 
                     return (
-                      <g key={`highlight-leg-${legIndex}`}>
+                      <g key={`highlight-leg-${leg_index}`}>
                         <line
                           x1={legStyle.position.startX}
                           y1={legStyle.position.startY}
@@ -494,18 +494,18 @@ export const DroppedLegoDisplay: React.FC<DroppedLegoDisplayProps> = memo(
 
                 {/* Layer 3: Interactive leg endpoints and logical leg interactions - with LOD */}
                 {lod.showLegs &&
-                  lego.style!.legStyles.map((legStyle, legIndex) => {
-                    const isLogical = lego.logical_legs.includes(legIndex);
-                    const legColor = lego.style!.getLegColor(legIndex);
+                  lego.style!.legStyles.map((legStyle, leg_index) => {
+                    const isLogical = lego.logical_legs.includes(leg_index);
+                    const legColor = lego.style!.getLegColor(leg_index);
 
-                    const shouldHide = legHiddenStates[legIndex];
+                    const shouldHide = legHiddenStates[leg_index];
 
                     if (shouldHide) {
                       return null;
                     }
 
                     return (
-                      <g key={`interactive-leg-${legIndex}`}>
+                      <g key={`interactive-leg-${leg_index}`}>
                         {/* Logical leg interactive line - rendered on top for clicks */}
                         {isLogical && (
                           <line
@@ -531,7 +531,7 @@ export const DroppedLegoDisplay: React.FC<DroppedLegoDisplayProps> = memo(
                             }}
                             onClick={(e) => {
                               e.stopPropagation();
-                              handleLegClick(lego.instanceId, legIndex);
+                              handleLegClick(lego.instance_id, leg_index);
                             }}
                           />
                         )}
@@ -552,7 +552,7 @@ export const DroppedLegoDisplay: React.FC<DroppedLegoDisplayProps> = memo(
                           }}
                           onMouseDown={(e) => {
                             e.stopPropagation();
-                            handleLegMouseDown(e, lego.instanceId, legIndex);
+                            handleLegMouseDown(e, lego.instance_id, leg_index);
                           }}
                           onMouseOver={(e) => {
                             const circle = e.target as SVGCircleElement;
@@ -566,7 +566,7 @@ export const DroppedLegoDisplay: React.FC<DroppedLegoDisplayProps> = memo(
                           }}
                           onMouseUp={(e) => {
                             e.stopPropagation();
-                            handleLegMouseUp(e, legIndex);
+                            handleLegMouseUp(e, leg_index);
                           }}
                         />
                       </g>
@@ -597,7 +597,7 @@ export const DroppedLegoDisplay: React.FC<DroppedLegoDisplayProps> = memo(
                               dominantBaseline="middle"
                               fill={isSelected ? "white" : "#000000"}
                             >
-                              {lego.shortName}
+                              {lego.short_name}
                             </text>
                             <text
                               x={size / 2}
@@ -607,7 +607,7 @@ export const DroppedLegoDisplay: React.FC<DroppedLegoDisplayProps> = memo(
                               dominantBaseline="middle"
                               fill={isSelected ? "white" : "#000000"}
                             >
-                              {lego.instanceId}
+                              {lego.instance_id}
                             </text>
                           </g>
                         ) : (
@@ -620,7 +620,7 @@ export const DroppedLegoDisplay: React.FC<DroppedLegoDisplayProps> = memo(
                             dominantBaseline="middle"
                             fill={isSelected ? "white" : "#000000"}
                           >
-                            {lego.instanceId}
+                            {lego.instance_id}
                           </text>
                         )}
                       </g>
@@ -637,13 +637,13 @@ export const DroppedLegoDisplay: React.FC<DroppedLegoDisplayProps> = memo(
                       >
                         {lod.showShortName && lego.style!.displayShortName ? (
                           <>
-                            {lego.shortName}
+                            {lego.short_name}
                             <tspan x="0" dy="12">
-                              {lego.instanceId}
+                              {lego.instance_id}
                             </tspan>
                           </>
                         ) : (
-                          lego.instanceId
+                          lego.instance_id
                         )}
                       </text>
                     )}
@@ -654,19 +654,19 @@ export const DroppedLegoDisplay: React.FC<DroppedLegoDisplayProps> = memo(
                 {!isScalarLego(lego) &&
                   !demoMode &&
                   lod.showLegLabels &&
-                  lego.style!.legStyles.map((legStyle, legIndex) => {
+                  lego.style!.legStyles.map((legStyle, leg_index) => {
                     // If the leg is hidden, don't render the label
-                    if (legHiddenStates[legIndex]) return null;
+                    if (legHiddenStates[leg_index]) return null;
 
                     // Check if leg is connected using pre-calculated states
                     const isLegConnectedToSomething =
-                      legConnectionStates[legIndex] || false;
+                      legConnectionStates[leg_index] || false;
 
                     // If leg is not connected, always show the label
                     if (!isLegConnectedToSomething) {
                       return (
                         <text
-                          key={`${lego.instanceId}-label-${legIndex}`}
+                          key={`${lego.instance_id}-label-${leg_index}`}
                           x={legStyle.position.labelX}
                           y={legStyle.position.labelY}
                           fontSize="12"
@@ -675,7 +675,7 @@ export const DroppedLegoDisplay: React.FC<DroppedLegoDisplayProps> = memo(
                           dominantBaseline="middle"
                           style={{ pointerEvents: "none" }}
                         >
-                          {legIndex}
+                          {leg_index}
                         </text>
                       );
                     }
@@ -683,10 +683,10 @@ export const DroppedLegoDisplay: React.FC<DroppedLegoDisplayProps> = memo(
                     // Find the connected leg's style
                     const connection = legoConnections.find(
                       (c) =>
-                        (c.from.legoId === lego.instanceId &&
-                          c.from.legIndex === legIndex) ||
-                        (c.to.legoId === lego.instanceId &&
-                          c.to.legIndex === legIndex)
+                        (c.from.legoId === lego.instance_id &&
+                          c.from.leg_index === leg_index) ||
+                        (c.to.legoId === lego.instance_id &&
+                          c.to.leg_index === leg_index)
                     );
 
                     if (!connection) return null;
@@ -705,7 +705,7 @@ export const DroppedLegoDisplay: React.FC<DroppedLegoDisplayProps> = memo(
 
                     return (
                       <text
-                        key={`${lego.instanceId}-label-${legIndex}`}
+                        key={`${lego.instance_id}-label-${leg_index}`}
                         x={legStyle.position.labelX}
                         y={legStyle.position.labelY}
                         fontSize="12"
@@ -714,7 +714,7 @@ export const DroppedLegoDisplay: React.FC<DroppedLegoDisplayProps> = memo(
                         dominantBaseline="middle"
                         style={{ pointerEvents: "none" }}
                       >
-                        {legIndex}
+                        {leg_index}
                       </text>
                     );
                   })}
diff --git a/app/ui/src/features/lego/LegoStyles.ts b/app/ui/src/features/lego/LegoStyles.ts
index 080d8aa3..e29ded9d 100644
--- a/app/ui/src/features/lego/LegoStyles.ts
+++ b/app/ui/src/features/lego/LegoStyles.ts
@@ -123,7 +123,7 @@ export abstract class LegoStyle {
     );
   }
 
-  getLegHighlightPauliOperator = (legIndex: number) => {
+  getLegHighlightPauliOperator = (leg_index: number) => {
     // First check if there's a pushed leg
     const h = this.lego.parity_check_matrix;
     const num_legs = h[0].length / 2;
@@ -142,8 +142,8 @@ export abstract class LegoStyle {
       });
     }
 
-    const xPart = combinedRow[legIndex];
-    const zPart = combinedRow[legIndex + num_legs];
+    const xPart = combinedRow[leg_index];
+    const zPart = combinedRow[leg_index + num_legs];
 
     if (xPart === 1 && zPart === 0) return PauliOperator.X;
     if (xPart === 0 && zPart === 1) return PauliOperator.Z;
@@ -181,19 +181,19 @@ export abstract class LegoStyle {
   }
 
   private calculateLegStyle(
-    legIndex: number,
+    leg_index: number,
     forSvg: boolean = false
   ): LegStyle {
-    const isLogical = this.lego.logical_legs.includes(legIndex);
-    const isGauge = this.lego.gauge_legs.includes(legIndex);
+    const isLogical = this.lego.logical_legs.includes(leg_index);
+    const isGauge = this.lego.gauge_legs.includes(leg_index);
     const legCount = this.lego.numberOfLegs;
-    const highlightPauliOperator = this.getLegHighlightPauliOperator(legIndex);
+    const highlightPauliOperator = this.getLegHighlightPauliOperator(leg_index);
     const isHighlighted = highlightPauliOperator !== PauliOperator.I;
 
-    if (this.lego.instanceId === "14") {
+    if (this.lego.instance_id === "14") {
       console.log(
         "calculateLegStyle",
-        legIndex,
+        leg_index,
         forSvg,
         this.lego.selectedMatrixRows
       );
@@ -209,7 +209,7 @@ export abstract class LegoStyle {
       const sortedLogicalLegs = [...this.lego.logical_legs].sort(
         (a, b) => a - b
       );
-      const logicalIndex = sortedLogicalLegs.indexOf(legIndex);
+      const logicalIndex = sortedLogicalLegs.indexOf(leg_index);
 
       if (logicalLegsCount === 1) {
         // Single logical leg points straight up
@@ -256,7 +256,7 @@ export abstract class LegoStyle {
       };
     } else if (isGauge) {
       // For gauge legs, calculate angle from bottom
-      const angle = Math.PI + (2 * Math.PI * legIndex) / legCount;
+      const angle = Math.PI + (2 * Math.PI * leg_index) / legCount;
       return {
         angle,
         length: 40,
@@ -283,7 +283,7 @@ export abstract class LegoStyle {
         .sort((a, b) => a - b);
 
       // Find the index of the current leg in the physical legs array
-      const physicalIndex = physicalLegIndices.indexOf(legIndex);
+      const physicalIndex = physicalLegIndices.indexOf(leg_index);
 
       if (physicalLegsCount === 1) {
         // Single physical leg points straight down
@@ -354,8 +354,8 @@ export abstract class LegoStyle {
     }
   }
 
-  getLegColor(legIndex: number): string {
-    const legStyle = this.legStyles[legIndex];
+  getLegColor(leg_index: number): string {
+    const legStyle = this.legStyles[leg_index];
     return legStyle.color;
   }
 }
@@ -566,32 +566,32 @@ export class ScalarStyle extends LegoStyle {
   }
 }
 export function getLegoStyle(
-  id: string,
+  type_id: string,
   numLegs: number,
   lego: DroppedLego
 ): LegoStyle {
   if (numLegs === 0) {
-    return new ScalarStyle(id, lego);
-  } else if (id === "h") {
-    return new HadamardStyle(id, lego);
-  } else if (id === Z_REP_CODE || id === X_REP_CODE) {
+    return new ScalarStyle(type_id, lego);
+  } else if (type_id === "h") {
+    return new HadamardStyle(type_id, lego);
+  } else if (type_id === Z_REP_CODE || type_id === X_REP_CODE) {
     if (numLegs > 2) {
-      return new RepetitionCodeStyle(id, lego);
+      return new RepetitionCodeStyle(type_id, lego);
     } else if (numLegs === 2) {
-      return new IdentityStyle(id, lego);
+      return new IdentityStyle(type_id, lego);
     } else if (numLegs === 1) {
       return new StopperStyle(
-        id === Z_REP_CODE ? "stopper_z" : "stopper_x",
+        type_id === Z_REP_CODE ? "stopper_z" : "stopper_x",
         lego
       );
     } else {
-      return new GenericStyle(id, lego);
+      return new GenericStyle(type_id, lego);
     }
-  } else if (id.includes("stopper")) {
-    return new StopperStyle(id, lego);
-  } else if (id === "identity") {
-    return new IdentityStyle(id, lego);
+  } else if (type_id.includes("stopper")) {
+    return new StopperStyle(type_id, lego);
+  } else if (type_id === "identity") {
+    return new IdentityStyle(type_id, lego);
   } else {
-    return new GenericStyle(id, lego);
+    return new GenericStyle(type_id, lego);
   }
 }
diff --git a/app/ui/src/features/lego/LegoSvgRenderer.ts b/app/ui/src/features/lego/LegoSvgRenderer.ts
index 93c525cb..489ee768 100644
--- a/app/ui/src/features/lego/LegoSvgRenderer.ts
+++ b/app/ui/src/features/lego/LegoSvgRenderer.ts
@@ -51,8 +51,8 @@ export class LegoSvgRenderer {
 
     // Generate logical legs SVG
     const logicalLegsSvg = legStyles
-      .map((legStyle, legIndex) => {
-        const isLogical = lego.logical_legs.includes(legIndex);
+      .map((legStyle, leg_index) => {
+        const isLogical = lego.logical_legs.includes(leg_index);
         if (!isLogical) return "";
 
         const legColor = legStyle.color;
@@ -158,11 +158,11 @@ export class LegoSvgRenderer {
           <g transform="translate(-${size / 2}, -${size / 2})">
             <text x="${size / 2}" y="${size / 2 - 6}" font-size="12" font-weight="bold" 
                   text-anchor="middle" dominant-baseline="middle" fill="${textColor}">
-              ${lego.shortName}
+              ${lego.short_name}
             </text>
             <text x="${size / 2}" y="${size / 2 + 6}" font-size="12" 
                   text-anchor="middle" dominant-baseline="middle" fill="${textColor}">
-              ${lego.instanceId}
+              ${lego.instance_id}
             </text>
           </g>
         `;
@@ -171,7 +171,7 @@ export class LegoSvgRenderer {
           <g transform="translate(-${size / 2}, -${size / 2})">
             <text x="${size / 2}" y="${size / 2}" font-size="12" font-weight="bold" 
                   text-anchor="middle" dominant-baseline="middle" fill="${textColor}">
-              ${lego.instanceId}
+              ${lego.instance_id}
             </text>
           </g>
         `;
@@ -182,15 +182,15 @@ export class LegoSvgRenderer {
         return `
           <text x="0" y="${yOffset}" font-size="10" font-weight="bold" 
                 text-anchor="middle" dominant-baseline="middle" fill="${textColor}">
-            ${lego.shortName}
-            <tspan x="0" dy="12">${lego.instanceId}</tspan>
+            ${lego.short_name}
+            <tspan x="0" dy="12">${lego.instance_id}</tspan>
           </text>
         `;
       } else {
         return `
           <text x="0" y="${yOffset}" font-size="10" font-weight="bold" 
                 text-anchor="middle" dominant-baseline="middle" fill="${textColor}">
-            ${lego.instanceId}
+            ${lego.instance_id}
           </text>
         `;
       }
@@ -206,13 +206,13 @@ export class LegoSvgRenderer {
 
     // This is a simplified version - you might want to port the full logic from DroppedLegoDisplay
     return legStyles
-      .map((legStyle, legIndex) => {
+      .map((legStyle, leg_index) => {
         // Check if leg is connected
         const isLegConnected = connections.some(
           (c: Connection) =>
-            (c.from.legoId === lego.instanceId &&
-              c.from.legIndex === legIndex) ||
-            (c.to.legoId === lego.instanceId && c.to.legIndex === legIndex)
+            (c.from.legoId === lego.instance_id &&
+              c.from.leg_index === leg_index) ||
+            (c.to.legoId === lego.instance_id && c.to.leg_index === leg_index)
         );
 
         // Simple logic: show label if not connected or if not hiding connected legs
@@ -220,7 +220,7 @@ export class LegoSvgRenderer {
           return `
             <text x="${legStyle.position.labelX}" y="${legStyle.position.labelY}" font-size="12" fill="#666666" 
                   text-anchor="middle" dominant-baseline="middle">
-              ${legIndex}
+              ${leg_index}
             </text>
           `;
         }
diff --git a/app/ui/src/features/lego/Legos.ts b/app/ui/src/features/lego/Legos.ts
index b945a64c..f103571b 100644
--- a/app/ui/src/features/lego/Legos.ts
+++ b/app/ui/src/features/lego/Legos.ts
@@ -102,7 +102,7 @@ export class Legos {
       {
         type_id: LegoType.T6,
         name: "[[6,0,3]] tensor",
-        shortName: "T6",
+        short_name: "T6",
         description: "[[6,0,3]] encoding tensor",
         parity_check_matrix: this.encoding_tensor_603,
         logical_legs: [4, 5],
@@ -113,7 +113,7 @@ export class Legos {
       {
         type_id: LegoType.T5,
         name: "[[5,1,2]] tensor",
-        shortName: "T5",
+        short_name: "T5",
         description: "[[5,1,2]] encoding tensor",
         parity_check_matrix: this.encoding_tensor_512,
         logical_legs: [4],
@@ -124,7 +124,7 @@ export class Legos {
       {
         type_id: LegoType.H,
         name: "Hadamard",
-        shortName: "H",
+        short_name: "H",
         description: "Hadamard tensor",
         parity_check_matrix: this.h,
         logical_legs: [],
@@ -138,7 +138,7 @@ export class Legos {
       {
         type_id: LegoType.ZREP,
         name: "Z-Repetition Code",
-        shortName: "ZREP3",
+        short_name: "ZREP3",
         description: "Bitflip code, ZZ stabilizers",
         is_dynamic: true,
         parameters: { d: 3 },
@@ -149,7 +149,7 @@ export class Legos {
       {
         type_id: LegoType.XREP,
         name: "X-Repetition Code",
-        shortName: "XREP3",
+        short_name: "XREP3",
         description: "Phase flip code, XX stabilizers",
         is_dynamic: true,
         parameters: { d: 3 },
@@ -160,7 +160,7 @@ export class Legos {
       {
         type_id: LegoType.ID,
         name: "Identity",
-        shortName: "I",
+        short_name: "I",
         description: "Identity tensor",
         parity_check_matrix: this.identity,
         logical_legs: [],
@@ -171,7 +171,7 @@ export class Legos {
       {
         type_id: "steane",
         name: "Steane Code",
-        shortName: "STN",
+        short_name: "STN",
         description: "Steane code encoding tensor",
         parity_check_matrix: this.steane_code_813_encoding_tensor,
         logical_legs: [7],
@@ -182,7 +182,7 @@ export class Legos {
       {
         type_id: "832",
         name: "[[8,3,2]] code",
-        shortName: "[[8,3,2]]",
+        short_name: "[[8,3,2]]",
         description: "[[8,3,2]] encoding tensor with all 3 logical legs",
 
         parity_check_matrix: [
@@ -206,7 +206,7 @@ export class Legos {
       {
         type_id: "15qrm",
         name: "[[15,1,3]] QRM",
-        shortName: "QRM15",
+        short_name: "QRM15",
         description: "[[15,1,3]] Quantum Reed-Muller code encoding tensor",
         // prettier-ignore
         parity_check_matrix: [
@@ -238,7 +238,7 @@ export class Legos {
     return {
       type_id: LegoType.STOPPER_I,
       name: "Identity Stopper",
-      shortName: "I",
+      short_name: "I",
       description: "Identity stopper tensor",
       parity_check_matrix: this.stopper_i_paulis,
       logical_legs: [],
@@ -251,7 +251,7 @@ export class Legos {
     return {
       type_id: LegoType.STOPPER_Z,
       name: "Z Stopper",
-      shortName: "Z",
+      short_name: "Z",
       description: "Z-type stopper tensor",
       parity_check_matrix: this.stopper_z_paulis,
       logical_legs: [],
@@ -264,7 +264,7 @@ export class Legos {
     return {
       type_id: LegoType.STOPPER_X,
       name: "X Stopper",
-      shortName: "X",
+      short_name: "X",
       description: "X-type stopper tensor",
       parity_check_matrix: this.stopper_x_paulis,
       logical_legs: [],
@@ -314,7 +314,7 @@ export class Legos {
   public static createDynamicLego(
     legoId: string,
     numLegs: number,
-    instanceId: string,
+    instance_id: string,
     logicalPosition: LogicalPoint
   ): DroppedLego {
     const data = this.getDynamicLego({
@@ -324,11 +324,11 @@ export class Legos {
       }
     });
 
-    return new DroppedLego(data, logicalPosition, instanceId);
+    return new DroppedLego(data, logicalPosition, instance_id);
   }
 }
 
-export function recognize_parity_check_matrix(h: GF2): string | null {
+export function recognize_parityCheckMatrix(h: GF2): string | null {
   // Get all available legos
   const legos = Legos.listAvailableLegos();
 
diff --git a/app/ui/src/features/lego/LegosLayer.tsx b/app/ui/src/features/lego/LegosLayer.tsx
index 940f0f6a..7e8b3454 100644
--- a/app/ui/src/features/lego/LegosLayer.tsx
+++ b/app/ui/src/features/lego/LegosLayer.tsx
@@ -43,7 +43,7 @@ export const LegosLayer: React.FC = () => {
       dragState?.draggingStage === DraggingStage.DRAGGING
     ) {
       tensorNetwork.legos.forEach((lego) => {
-        draggedIds.add(lego.instanceId);
+        draggedIds.add(lego.instance_id);
       });
     }
 
diff --git a/app/ui/src/features/lego/customLegoService.ts b/app/ui/src/features/lego/customLegoService.ts
index 2caafffd..60ac8706 100644
--- a/app/ui/src/features/lego/customLegoService.ts
+++ b/app/ui/src/features/lego/customLegoService.ts
@@ -11,31 +11,31 @@ export interface CustomLegoCreationOptions {
 export class CustomLegoService {
   static createCustomLego(
     matrix: number[][],
-    logicalLegs: number[],
+    logical_legs: number[],
     position: { x: number; y: number }
   ): void {
     const { addDroppedLego, addOperation, newInstanceId } =
       useCanvasStore.getState();
 
-    const instanceId = newInstanceId();
+    const instance_id = newInstanceId();
     const newLego: DroppedLego = new DroppedLego(
       {
         // Generate unique ID to avoid caching collisions
         type_id:
           "custom-" +
-          instanceId +
+          instance_id +
           "-" +
           Math.random().toString(36).substring(2, 15),
         name: "Custom Lego",
-        shortName: "Custom",
+        short_name: "Custom",
         description: "Custom lego with user-defined parity check matrix",
         parity_check_matrix: matrix,
-        logical_legs: logicalLegs,
+        logical_legs: logical_legs,
         gauge_legs: []
       },
 
       new LogicalPoint(position.x, position.y),
-      instanceId
+      instance_id
     );
 
     // Add to store
diff --git a/app/ui/src/features/network-apis/TannerDialog.tsx b/app/ui/src/features/network-apis/TannerDialog.tsx
index be71e706..f7690307 100644
--- a/app/ui/src/features/network-apis/TannerDialog.tsx
+++ b/app/ui/src/features/network-apis/TannerDialog.tsx
@@ -22,7 +22,7 @@ import { useState, useEffect } from "react";
 interface TannerDialogProps {
   isOpen: boolean;
   onClose: () => void;
-  onSubmit: (matrix: number[][], logicalLegs: number[]) => void;
+  onSubmit: (matrix: number[][], logical_legs: number[]) => void;
   title?: string;
   cssOnly?: boolean;
 }
@@ -46,7 +46,7 @@ export const TannerDialog: React.FC<TannerDialogProps> = ({
   const [matrixText, setMatrixText] = useState("");
   const [error, setError] = useState("");
   const [useStabilizer, setUseStabilizer] = useState(true);
-  const [logicalLegs, setLogicalLegs] = useState<number[]>([]);
+  const [logical_legs, setLogicalLegs] = useState<number[]>([]);
   const [numLegs, setNumLegs] = useState(0);
 
   // Set default value when dialog opens
@@ -257,7 +257,7 @@ export const TannerDialog: React.FC<TannerDialogProps> = ({
   const handleSubmit = () => {
     const matrix = validateMatrix(matrixText);
     if (matrix) {
-      onSubmit(matrix, logicalLegs);
+      onSubmit(matrix, logical_legs);
       onClose();
     } else {
       toast({
@@ -344,13 +344,13 @@ export const TannerDialog: React.FC<TannerDialogProps> = ({
                   {Array.from({ length: numLegs }, (_, i) => (
                     <Checkbox
                       key={i}
-                      isChecked={logicalLegs.includes(i)}
+                      isChecked={logical_legs.includes(i)}
                       onChange={(e) => {
                         if (e.target.checked) {
-                          setLogicalLegs([...logicalLegs, i]);
+                          setLogicalLegs([...logical_legs, i]);
                         } else {
                           setLogicalLegs(
-                            logicalLegs.filter((leg) => leg !== i)
+                            logical_legs.filter((leg) => leg !== i)
                           );
                         }
                       }}
diff --git a/app/ui/src/features/python-export/constructionCode.test.ts b/app/ui/src/features/python-export/constructionCode.test.ts
index f2f45b94..801e0c3c 100644
--- a/app/ui/src/features/python-export/constructionCode.test.ts
+++ b/app/ui/src/features/python-export/constructionCode.test.ts
@@ -29,7 +29,7 @@ tn = TensorNetwork(nodes)
           {
             type_id: "x_rep_code",
             name: "X-Repetition Code",
-            shortName: "XREP3",
+            short_name: "XREP3",
             description: "Phase flip code, XX stabilizers",
             is_dynamic: true,
             parameters: { d: 3 },
@@ -76,7 +76,7 @@ tn = TensorNetwork(nodes)
           {
             type_id: "x_rep_code",
             name: "X-Repetition Code",
-            shortName: "XREP3",
+            short_name: "XREP3",
             description: "Phase flip code, XX stabilizers",
             is_dynamic: true,
             parameters: { d: 3 },
@@ -95,7 +95,7 @@ tn = TensorNetwork(nodes)
           {
             type_id: "steane",
             name: "Steane Code",
-            shortName: "STN",
+            short_name: "STN",
             description: "Steane code encoding tensor",
             parity_check_matrix: [
               [0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0],
@@ -117,7 +117,7 @@ tn = TensorNetwork(nodes)
           {
             type_id: "x_rep_code",
             name: "X-Repetition Code",
-            shortName: "XREP3",
+            short_name: "XREP3",
             description: "Phase flip code, XX stabilizers",
             is_dynamic: true,
             parameters: { d: 4 },
@@ -137,7 +137,7 @@ tn = TensorNetwork(nodes)
           {
             type_id: "z_rep_code",
             name: "Z-Repetition Code",
-            shortName: "ZREP3",
+            short_name: "ZREP3",
             description: "Bitflip code, ZZ stabilizers",
             is_dynamic: true,
             parameters: { d: 3 },
@@ -157,7 +157,7 @@ tn = TensorNetwork(nodes)
           {
             type_id: "stopper_x",
             name: "X Stopper",
-            shortName: "X",
+            short_name: "X",
             description: "X Stopper",
             parity_check_matrix: [[1, 0]],
             logical_legs: [],
@@ -169,20 +169,20 @@ tn = TensorNetwork(nodes)
       ],
       connections: [
         new Connection(
-          { legoId: "1", legIndex: 0 },
-          { legoId: "3", legIndex: 7 }
+          { legoId: "1", leg_index: 0 },
+          { legoId: "3", leg_index: 7 }
         ),
         new Connection(
-          { legoId: "1", legIndex: 1 },
-          { legoId: "2", legIndex: 2 }
+          { legoId: "1", leg_index: 1 },
+          { legoId: "2", leg_index: 2 }
         ),
         new Connection(
-          { legoId: "4", legIndex: 0 },
-          { legoId: "1", legIndex: 2 }
+          { legoId: "4", leg_index: 0 },
+          { legoId: "1", leg_index: 2 }
         ),
         new Connection(
-          { legoId: "1", legIndex: 3 },
-          { legoId: "5", legIndex: 0 }
+          { legoId: "1", leg_index: 3 },
+          { legoId: "5", leg_index: 0 }
         )
       ]
     });
@@ -191,6 +191,7 @@ tn = TensorNetwork(nodes)
 
     const python_script = code + "\n\n" + "print(tn.conjoin_nodes().h)";
     // Execute Python script and handle output
+    console.log("this file", process.env.PYTHONPATH);
     await new Promise<void>((resolve, reject) => {
       exec(`python3 -c '${python_script}'`, (error, stdout, stderr) => {
         if (error) {
@@ -211,7 +212,7 @@ tn = TensorNetwork(nodes)
           );
 
         // prettier-ignore
-        const expected_parity_check_matrix = [
+        const expected_parityCheckMatrix = [
             [1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
             [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1],
             [0, 0, 0, 1, 0, 1, 0, 1, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],
@@ -226,7 +227,7 @@ tn = TensorNetwork(nodes)
             [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 1]
         ];
 
-        expect(parity_check_matrix).toEqual(expected_parity_check_matrix);
+        expect(parity_check_matrix).toEqual(expected_parityCheckMatrix);
         resolve();
       });
     });
diff --git a/app/ui/src/features/tasks/TaskPanel.tsx b/app/ui/src/features/tasks/TaskPanel.tsx
index c33c0e55..bcc6a436 100644
--- a/app/ui/src/features/tasks/TaskPanel.tsx
+++ b/app/ui/src/features/tasks/TaskPanel.tsx
@@ -27,7 +27,7 @@ import {
 } from "@supabase/supabase-js";
 import { FaFileAlt, FaTrash } from "react-icons/fa";
 import { userContextSupabase } from "../../config/supabaseClient.ts";
-import { getAccessToken } from "../../lib/auth.ts";
+import { getAccessToken } from "../auth/auth.ts";
 import { getApiUrl } from "../../config/config.ts";
 import { getAxiosErrorMessage } from "../../lib/errors.ts";
 import axios, { AxiosError } from "axios";
diff --git a/app/ui/src/features/weight-enumerator/WeightEnumeratorCalculationDialog.tsx b/app/ui/src/features/weight-enumerator/WeightEnumeratorCalculationDialog.tsx
index 1be1d674..0f4afd90 100644
--- a/app/ui/src/features/weight-enumerator/WeightEnumeratorCalculationDialog.tsx
+++ b/app/ui/src/features/weight-enumerator/WeightEnumeratorCalculationDialog.tsx
@@ -36,13 +36,13 @@ const WeightEnumeratorCalculationDialog: React.FC<
     mainNetworkConnections
   );
   const [truncateLength, setTruncateLength] = useState<string>("");
-  // Use string keys for easy lookup: "instanceId-legIndex"
+  // Use string keys for easy lookup: "instance_id-leg_index"
   const externalKeys = useMemo(
-    () => externalLegs.map((l) => `${l.instanceId}-${l.legIndex}`),
+    () => externalLegs.map((l) => `${l.instance_id}-${l.leg_index}`),
     [externalLegs]
   );
   const danglingKeys = useMemo(
-    () => danglingLegs.map((l) => `${l.instanceId}-${l.legIndex}`),
+    () => danglingLegs.map((l) => `${l.instance_id}-${l.leg_index}`),
     [danglingLegs]
   );
 
@@ -101,10 +101,10 @@ const WeightEnumeratorCalculationDialog: React.FC<
   // Collect selected legs
   const selectedLegs: TensorNetworkLeg[] = [
     ...externalLegs.filter((l) =>
-      selectedExternal.has(`${l.instanceId}-${l.legIndex}`)
+      selectedExternal.has(`${l.instance_id}-${l.leg_index}`)
     ),
     ...danglingLegs.filter((l) =>
-      selectedDangling.has(`${l.instanceId}-${l.legIndex}`)
+      selectedDangling.has(`${l.instance_id}-${l.leg_index}`)
     )
   ];
 
@@ -192,7 +192,7 @@ const WeightEnumeratorCalculationDialog: React.FC<
                     overflowY="auto"
                   >
                     {externalLegs.map((leg) => {
-                      const key = `${leg.instanceId}-${leg.legIndex}`;
+                      const key = `${leg.instance_id}-${leg.leg_index}`;
                       return (
                         <Checkbox
                           key={key}
@@ -205,7 +205,7 @@ const WeightEnumeratorCalculationDialog: React.FC<
                             )
                           }
                         >
-                          {leg.instanceId} - {leg.legIndex}
+                          {leg.instance_id} - {leg.leg_index}
                         </Checkbox>
                       );
                     })}
@@ -248,7 +248,7 @@ const WeightEnumeratorCalculationDialog: React.FC<
                     overflowY="auto"
                   >
                     {danglingLegs.map((leg) => {
-                      const key = `${leg.instanceId}-${leg.legIndex}`;
+                      const key = `${leg.instance_id}-${leg.leg_index}`;
                       return (
                         <Checkbox
                           key={key}
@@ -261,7 +261,7 @@ const WeightEnumeratorCalculationDialog: React.FC<
                             )
                           }
                         >
-                          {leg.instanceId} - {leg.legIndex}
+                          {leg.instance_id} - {leg.leg_index}
                         </Checkbox>
                       );
                     })}
diff --git a/app/ui/src/features/weight-enumerator/weightEnumeratorService.ts b/app/ui/src/features/weight-enumerator/weightEnumeratorService.ts
index 1bde7ddf..540f790b 100644
--- a/app/ui/src/features/weight-enumerator/weightEnumeratorService.ts
+++ b/app/ui/src/features/weight-enumerator/weightEnumeratorService.ts
@@ -1,6 +1,6 @@
 import { TensorNetwork, TensorNetworkLeg } from "../../lib/TensorNetwork";
 import { getApiUrl } from "../../config/config";
-import { getAccessToken } from "../../lib/auth";
+import { getAccessToken } from "../auth/auth";
 import { config } from "../../config/config";
 import { User } from "@supabase/supabase-js";
 import { useToast } from "@chakra-ui/react";
@@ -78,10 +78,10 @@ export class WeightEnumeratorService {
           payload: {
             legos: tensorNetwork.legos.reduce(
               (acc, lego) => {
-                acc[lego.instanceId] = {
-                  instanceId: lego.instanceId,
-                  shortName: lego.shortName || "Generic Lego",
-                  name: lego.shortName || "Generic Lego",
+                acc[lego.instance_id] = {
+                  instance_id: lego.instance_id,
+                  short_name: lego.short_name || "Generic Lego",
+                  name: lego.short_name || "Generic Lego",
                   id: lego.type_id,
                   parity_check_matrix: lego.parity_check_matrix,
                   logical_legs: lego.logical_legs,
diff --git a/app/ui/src/hooks/useVisibleLegos.ts b/app/ui/src/hooks/useVisibleLegos.ts
index 6aa0daa5..8fc7bbdd 100644
--- a/app/ui/src/hooks/useVisibleLegos.ts
+++ b/app/ui/src/hooks/useVisibleLegos.ts
@@ -22,7 +22,7 @@ export const useVisibleLegoIds = () => {
     ) {
       console.warn("Invalid viewport in calculateVisibleLegos:", viewport);
 
-      return droppedLegos.map((lego) => lego.instanceId);
+      return droppedLegos.map((lego) => lego.instance_id);
     }
 
     // Calculate viewport bounds with some padding for connections
@@ -37,7 +37,7 @@ export const useVisibleLegoIds = () => {
       console.warn("Invalid viewport in calculateVisibleLegos:", viewport);
 
       return droppedLegos.map((lego) => {
-        return lego.instanceId;
+        return lego.instance_id;
       });
     }
 
@@ -54,7 +54,7 @@ export const useVisibleLegoIds = () => {
     });
 
     // Get connected legos (connected to visible ones, even if outside viewport)
-    const visibleIds = new Set(directlyVisible.map((l) => l.instanceId));
+    const visibleIds = new Set(directlyVisible.map((l) => l.instance_id));
     const connectedIds = new Set<string>();
 
     connections.forEach((conn) => {
@@ -69,11 +69,11 @@ export const useVisibleLegoIds = () => {
     // Combine visible and connected legos
     const connectedLegos = droppedLegos.filter(
       (lego) =>
-        connectedIds.has(lego.instanceId) && !visibleIds.has(lego.instanceId)
+        connectedIds.has(lego.instance_id) && !visibleIds.has(lego.instance_id)
     );
 
     const visibleLegoIds = [...directlyVisible, ...connectedLegos].map(
-      (lego) => lego.instanceId
+      (lego) => lego.instance_id
     );
 
     return visibleLegoIds;
diff --git a/app/ui/src/lib/StabilizerCodeTensor.ts b/app/ui/src/lib/StabilizerCodeTensor.ts
index aa703c32..d77898ca 100644
--- a/app/ui/src/lib/StabilizerCodeTensor.ts
+++ b/app/ui/src/lib/StabilizerCodeTensor.ts
@@ -23,9 +23,9 @@ export class StabilizerCodeTensor {
     legToCol: Map<string, number>,
     leg: TensorNetworkLeg
   ): void {
-    legToCol.delete(`${leg.instanceId}:${leg.legIndex}`);
+    legToCol.delete(`${leg.instance_id}:${leg.leg_index}`);
     legToCol.forEach((value, key) => {
-      if (value > leg.legIndex) {
+      if (value > leg.leg_index) {
         legToCol.set(key, value - 1);
       }
     });
@@ -53,22 +53,22 @@ export class StabilizerCodeTensor {
 
     // Create a new leg to column mapping that includes both tensors
     const conjoinedLegToCol = new Map(
-      this.legs.map((leg, i) => [`${leg.instanceId}:${leg.legIndex}`, i])
+      this.legs.map((leg, i) => [`${leg.instance_id}:${leg.leg_index}`, i])
     );
     other.legs.forEach((leg, i) => {
-      conjoinedLegToCol.set(`${leg.instanceId}:${leg.legIndex}`, this.n + i);
+      conjoinedLegToCol.set(`${leg.instance_id}:${leg.leg_index}`, this.n + i);
     });
 
     const otherLegToCol = new Map(
-      other.legs.map((leg, i) => [`${leg.instanceId}:${leg.legIndex}`, i])
+      other.legs.map((leg, i) => [`${leg.instance_id}:${leg.leg_index}`, i])
     );
 
     // Perform initial conjoin
     let newH = conjoin(
       this.h,
       other.h,
-      conjoinedLegToCol.get(`${legs1[0].instanceId}:${legs1[0].legIndex}`)!,
-      otherLegToCol.get(`${legs2[0].instanceId}:${legs2[0].legIndex}`)!
+      conjoinedLegToCol.get(`${legs1[0].instance_id}:${legs1[0].leg_index}`)!,
+      otherLegToCol.get(`${legs2[0].instance_id}:${legs2[0].leg_index}`)!
     );
 
     // Remove the first pair of legs
@@ -78,8 +78,8 @@ export class StabilizerCodeTensor {
     for (let i = 1; i < legs1.length; i++) {
       newH = self_trace(
         newH,
-        conjoinedLegToCol.get(`${legs1[i].instanceId}:${legs1[i].legIndex}`)!,
-        conjoinedLegToCol.get(`${legs2[i].instanceId}:${legs2[i].legIndex}`)!
+        conjoinedLegToCol.get(`${legs1[i].instance_id}:${legs1[i].leg_index}`)!,
+        conjoinedLegToCol.get(`${legs2[i].instance_id}:${legs2[i].leg_index}`)!
       );
       this.removeLegs(conjoinedLegToCol, [legs1[i], legs2[i]]);
     }
@@ -90,14 +90,14 @@ export class StabilizerCodeTensor {
         (leg) =>
           !legs1.some(
             (l) =>
-              l.instanceId === leg.instanceId && l.legIndex === leg.legIndex
+              l.instance_id === leg.instance_id && l.leg_index === leg.leg_index
           )
       ),
       ...other.legs.filter(
         (leg) =>
           !legs2.some(
             (l) =>
-              l.instanceId === leg.instanceId && l.legIndex === leg.legIndex
+              l.instance_id === leg.instance_id && l.leg_index === leg.leg_index
           )
       )
     ];
@@ -114,15 +114,15 @@ export class StabilizerCodeTensor {
     }
 
     const legToCol = new Map(
-      this.legs.map((leg, i) => [`${leg.instanceId}:${leg.legIndex}`, i])
+      this.legs.map((leg, i) => [`${leg.instance_id}:${leg.leg_index}`, i])
     );
 
     let newH = this.h;
     for (let i = 0; i < legs1.length; i++) {
       newH = self_trace(
         newH,
-        legToCol.get(`${legs1[i].instanceId}:${legs1[i].legIndex}`)!,
-        legToCol.get(`${legs2[i].instanceId}:${legs2[i].legIndex}`)!
+        legToCol.get(`${legs1[i].instance_id}:${legs1[i].leg_index}`)!,
+        legToCol.get(`${legs2[i].instance_id}:${legs2[i].leg_index}`)!
       );
     }
     this.removeLegs(legToCol, [...legs1, ...legs2]);
@@ -134,7 +134,7 @@ export class StabilizerCodeTensor {
         (leg) =>
           ![...legs1, ...legs2].some(
             (l) =>
-              l.instanceId === leg.instanceId && l.legIndex === leg.legIndex
+              l.instance_id === leg.instance_id && l.leg_index === leg.leg_index
           )
       )
     );
@@ -145,8 +145,8 @@ export class StabilizerCodeTensor {
     const newLegs = [
       ...this.legs,
       ...other.legs.map((leg) => ({
-        instanceId: leg.instanceId,
-        legIndex: leg.legIndex
+        instance_id: leg.instance_id,
+        leg_index: leg.leg_index
       }))
     ];
 
diff --git a/app/ui/src/lib/TensorNetwork.test.ts b/app/ui/src/lib/TensorNetwork.test.ts
index a272217c..54d5ba2d 100644
--- a/app/ui/src/lib/TensorNetwork.test.ts
+++ b/app/ui/src/lib/TensorNetwork.test.ts
@@ -12,7 +12,7 @@ describe("TensorNetwork", () => {
         {
           type_id: "encoding_tensor_602",
           name: "Encoding Tensor 602",
-          shortName: "602",
+          short_name: "602",
           description: "Encoding Tensor 602",
 
           parity_check_matrix: [
@@ -33,7 +33,7 @@ describe("TensorNetwork", () => {
         {
           type_id: "stopper_i",
           name: "Identity Stopper",
-          shortName: "I",
+          short_name: "I",
           description: "Identity Stopper",
 
           parity_check_matrix: [[0, 0]],
@@ -47,7 +47,7 @@ describe("TensorNetwork", () => {
         {
           type_id: "stopper_i",
           name: "Identity Stopper",
-          shortName: "I",
+          short_name: "I",
           description: "Identity Stopper",
 
           parity_check_matrix: [[0, 0]],
@@ -62,12 +62,12 @@ describe("TensorNetwork", () => {
     // Create the connections
     const connections: Connection[] = [
       new Connection(
-        { legoId: "stop1", legIndex: 0 },
-        { legoId: "0", legIndex: 4 }
+        { legoId: "stop1", leg_index: 0 },
+        { legoId: "0", leg_index: 4 }
       ),
       new Connection(
-        { legoId: "stop2", legIndex: 0 },
-        { legoId: "0", legIndex: 5 }
+        { legoId: "stop2", leg_index: 0 },
+        { legoId: "0", leg_index: 5 }
       )
     ];
 
@@ -100,7 +100,7 @@ describe("TensorNetwork", () => {
           {
             type_id: "t5",
             name: "[[5,1,2]] tensor",
-            shortName: "T5",
+            short_name: "T5",
             description: "[[5,1,2]] encoding tensor",
             parity_check_matrix: [
               [1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
@@ -120,7 +120,7 @@ describe("TensorNetwork", () => {
           {
             type_id: "t5",
             name: "[[5,1,2]] tensor",
-            shortName: "T5",
+            short_name: "T5",
             description: "[[5,1,2]] encoding tensor",
             parity_check_matrix: [
               [1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
@@ -140,7 +140,7 @@ describe("TensorNetwork", () => {
           {
             type_id: "t5",
             name: "[[5,1,2]] tensor",
-            shortName: "T5",
+            short_name: "T5",
             description: "[[5,1,2]] encoding tensor",
             parity_check_matrix: [
               [1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
@@ -160,7 +160,7 @@ describe("TensorNetwork", () => {
           {
             type_id: "t5",
             name: "[[5,1,2]] tensor",
-            shortName: "T5",
+            short_name: "T5",
             description: "[[5,1,2]] encoding tensor",
             parity_check_matrix: [
               [1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
@@ -180,7 +180,7 @@ describe("TensorNetwork", () => {
           {
             type_id: "t5",
             name: "[[5,1,2]] tensor",
-            shortName: "T5",
+            short_name: "T5",
             description: "[[5,1,2]] encoding tensor",
             parity_check_matrix: [
               [1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
@@ -200,7 +200,7 @@ describe("TensorNetwork", () => {
           {
             type_id: "t5",
             name: "[[5,1,2]] tensor",
-            shortName: "T5",
+            short_name: "T5",
             description: "[[5,1,2]] encoding tensor",
             parity_check_matrix: [
               [1, 1, 1, 1, 0, 0, 0, 0, 0, 0],
@@ -219,36 +219,36 @@ describe("TensorNetwork", () => {
       ],
       connections: [
         new Connection(
-          { legoId: "5", legIndex: 0 },
-          { legoId: "6", legIndex: 3 }
+          { legoId: "5", leg_index: 0 },
+          { legoId: "6", leg_index: 3 }
         ),
         new Connection(
-          { legoId: "4", legIndex: 0 },
-          { legoId: "5", legIndex: 3 }
+          { legoId: "4", leg_index: 0 },
+          { legoId: "5", leg_index: 3 }
         ),
         new Connection(
-          { legoId: "4", legIndex: 2 },
-          { legoId: "3", legIndex: 3 }
+          { legoId: "4", leg_index: 2 },
+          { legoId: "3", leg_index: 3 }
         ),
         new Connection(
-          { legoId: "4", legIndex: 1 },
-          { legoId: "3", legIndex: 0 }
+          { legoId: "4", leg_index: 1 },
+          { legoId: "3", leg_index: 0 }
         ),
         new Connection(
-          { legoId: "5", legIndex: 2 },
-          { legoId: "2", legIndex: 3 }
+          { legoId: "5", leg_index: 2 },
+          { legoId: "2", leg_index: 3 }
         ),
         new Connection(
-          { legoId: "6", legIndex: 1 },
-          { legoId: "1", legIndex: 0 }
+          { legoId: "6", leg_index: 1 },
+          { legoId: "1", leg_index: 0 }
         ),
         new Connection(
-          { legoId: "2", legIndex: 1 },
-          { legoId: "1", legIndex: 2 }
+          { legoId: "2", leg_index: 1 },
+          { legoId: "1", leg_index: 2 }
         ),
         new Connection(
-          { legoId: "1", legIndex: 3 },
-          { legoId: "2", legIndex: 0 }
+          { legoId: "1", leg_index: 3 },
+          { legoId: "2", leg_index: 0 }
         )
       ]
     });
@@ -291,10 +291,10 @@ describe("TensorNetwork", () => {
       ])
     );
     expect(conjoined.legs).toEqual([
-      { instanceId: "1", legIndex: 0 },
-      { instanceId: "1", legIndex: 1 },
-      { instanceId: "2", legIndex: 0 },
-      { instanceId: "2", legIndex: 1 }
+      { instance_id: "1", leg_index: 0 },
+      { instance_id: "1", leg_index: 1 },
+      { instance_id: "2", leg_index: 0 },
+      { instance_id: "2", leg_index: 1 }
     ]);
   });
 });
diff --git a/app/ui/src/lib/TensorNetwork.ts b/app/ui/src/lib/TensorNetwork.ts
index 3e853b67..75b72650 100644
--- a/app/ui/src/lib/TensorNetwork.ts
+++ b/app/ui/src/lib/TensorNetwork.ts
@@ -12,14 +12,14 @@ export function findConnectedComponent(
   const visited = new Set<string>();
   const component: DroppedLego[] = [];
   const componentConnections: Connection[] = [];
-  const queue: string[] = [startLego.instanceId];
-  visited.add(startLego.instanceId);
+  const queue: string[] = [startLego.instance_id];
+  visited.add(startLego.instance_id);
 
   // First pass: collect all connected legos using BFS
   while (queue.length > 0) {
     const currentLegoId = queue.shift()!;
     const currentLego = droppedLegos.find(
-      (l) => l.instanceId === currentLegoId
+      (l) => l.instance_id === currentLegoId
     );
     if (!currentLego) continue;
     component.push(currentLego);
@@ -53,14 +53,14 @@ export function findConnectedComponent(
 }
 
 export interface TensorNetworkLeg {
-  instanceId: string;
-  legIndex: number;
+  instance_id: string;
+  leg_index: number;
 }
 
 export class TensorNetwork {
   private _legos: DroppedLego[];
   private _connections: Connection[];
-  public parityCheckMatrix?: number[][];
+  public parity_check_matrix?: number[][];
   public weightEnumerator?: string;
   public normalizerPolynomial?: string;
   public truncateLength?: number;
@@ -73,7 +73,7 @@ export class TensorNetwork {
   constructor(data: {
     legos: DroppedLego[];
     connections: Connection[];
-    parityCheckMatrix?: number[][];
+    parity_check_matrix?: number[][];
     weightEnumerator?: string;
     normalizerPolynomial?: string;
     truncateLength?: number;
@@ -87,7 +87,7 @@ export class TensorNetwork {
     console.assert(data.connections, "connections is required");
     this._legos = data.legos;
     this._connections = data.connections;
-    this.parityCheckMatrix = data.parityCheckMatrix;
+    this.parity_check_matrix = data.parity_check_matrix;
     this.weightEnumerator = data.weightEnumerator;
     this.normalizerPolynomial = data.normalizerPolynomial;
     this.truncateLength = data.truncateLength;
@@ -133,13 +133,14 @@ export class TensorNetwork {
     connections: Connection[]
   ) => {
     const sortedLegos = [...legos]
-      .sort((a, b) => a.instanceId.localeCompare(b.instanceId))
+      .sort((a, b) => a.instance_id.localeCompare(b.instance_id))
       .map(
-        (lego) => lego.type_id + "-" + lego.instanceId + "-" + lego.numberOfLegs
+        (lego) =>
+          lego.type_id + "-" + lego.instance_id + "-" + lego.numberOfLegs
       );
     const sortedConnections = [...connections].sort((a, b) => {
-      const aStr = `${a.from.legoId}${a.from.legIndex}${a.to.legoId}${a.to.legIndex}`;
-      const bStr = `${b.from.legoId}${b.from.legIndex}${b.to.legoId}${b.to.legIndex}`;
+      const aStr = `${a.from.legoId}${a.from.leg_index}${a.to.legoId}${a.to.leg_index}`;
+      const bStr = `${b.from.legoId}${b.from.leg_index}${b.to.legoId}${b.to.leg_index}`;
       return aStr.localeCompare(bStr);
     });
     const sig = JSON.stringify({
@@ -168,7 +169,7 @@ export class TensorNetwork {
         row.map((val: number) => `${val}`).join(", ")
       );
       code.push(
-        `    "${lego.instanceId}": StabilizerCodeTensorEnumerator(idx="${lego.instanceId}", h=GF2([`
+        `    "${lego.instance_id}": StabilizerCodeTensorEnumerator(idx="${lego.instance_id}", h=GF2([`
       );
       for (const row of matrix) {
         code.push(`            [${row}],`);
@@ -189,7 +190,7 @@ export class TensorNetwork {
     code.push("# Add traces");
     for (const conn of this.connections) {
       code.push(
-        `tn.self_trace("${conn.from.legoId}", "${conn.to.legoId}", [${conn.from.legIndex}], [${conn.to.legIndex}])`
+        `tn.self_trace("${conn.from.legoId}", "${conn.to.legoId}", [${conn.from.leg_index}], [${conn.to.leg_index}])`
       );
     }
 
@@ -204,34 +205,34 @@ export class TensorNetwork {
     const allLegs: TensorNetworkLeg[] = this.legos.flatMap((lego) => {
       const numLegs = lego.numberOfLegs;
       return Array.from({ length: numLegs }, (_, i) => ({
-        instanceId: lego.instanceId,
-        legIndex: i
+        instance_id: lego.instance_id,
+        leg_index: i
       }));
     });
     const connectedLegs = new Set<string>();
     mainNetworkConnections.forEach((conn) => {
-      connectedLegs.add(`${conn.from.legoId}:${conn.from.legIndex}`);
-      connectedLegs.add(`${conn.to.legoId}:${conn.to.legIndex}`);
+      connectedLegs.add(`${conn.from.legoId}:${conn.from.leg_index}`);
+      connectedLegs.add(`${conn.to.legoId}:${conn.to.leg_index}`);
     });
     // Legs in tensorNetwork but connected to something outside
-    const networkInstanceIds = new Set(this.legos.map((l) => l.instanceId));
+    const networkInstanceIds = new Set(this.legos.map((l) => l.instance_id));
     const externalLegs: TensorNetworkLeg[] = [];
     const danglingLegs: TensorNetworkLeg[] = [];
     allLegs.forEach((leg) => {
       // Find if this leg is connected
       const conn = mainNetworkConnections.find(
         (conn) =>
-          (conn.from.legoId === leg.instanceId &&
-            conn.from.legIndex === leg.legIndex) ||
-          (conn.to.legoId === leg.instanceId &&
-            conn.to.legIndex === leg.legIndex)
+          (conn.from.legoId === leg.instance_id &&
+            conn.from.leg_index === leg.leg_index) ||
+          (conn.to.legoId === leg.instance_id &&
+            conn.to.leg_index === leg.leg_index)
       );
       if (!conn) {
         danglingLegs.push(leg);
       } else {
         // If the other side is not in the network, it's external
         const other =
-          conn.from.legoId === leg.instanceId
+          conn.from.legoId === leg.instance_id
             ? conn.to.legoId
             : conn.from.legoId;
         if (!networkInstanceIds.has(other)) {
@@ -247,15 +248,15 @@ export class TensorNetwork {
     if (this.legos.length === 1 && this.connections.length === 0) {
       return new StabilizerCodeTensor(
         new GF2(this.legos[0].parity_check_matrix),
-        this.legos[0].instanceId,
+        this.legos[0].instance_id,
         Array.from({ length: this.legos[0].numberOfLegs }, (_, i) => ({
-          instanceId: this.legos[0].instanceId,
-          legIndex: i
+          instance_id: this.legos[0].instance_id,
+          leg_index: i
         }))
       );
     }
 
-    // Map from lego instanceId to its index in components list
+    // Map from lego instance_id to its index in components list
     type Component = {
       tensor: StabilizerCodeTensor;
       legos: Set<string>;
@@ -263,16 +264,16 @@ export class TensorNetwork {
     const components: Component[] = this.legos.map((lego) => ({
       tensor: new StabilizerCodeTensor(
         new GF2(lego.parity_check_matrix),
-        lego.instanceId,
+        lego.instance_id,
         Array.from({ length: lego.numberOfLegs }, (_, i) => ({
-          instanceId: lego.instanceId,
-          legIndex: i
+          instance_id: lego.instance_id,
+          leg_index: i
         }))
       ),
-      legos: new Set([lego.instanceId])
+      legos: new Set([lego.instance_id])
     }));
     const legoToComponent = new Map<string, number>();
-    this.legos.forEach((lego, i) => legoToComponent.set(lego.instanceId, i));
+    this.legos.forEach((lego, i) => legoToComponent.set(lego.instance_id, i));
 
     // Process each connection
     for (const conn of this.connections) {
@@ -289,8 +290,8 @@ export class TensorNetwork {
       if (comp1Idx === comp2Idx) {
         const comp = components[comp1Idx];
         comp.tensor = comp.tensor.selfTrace(
-          [{ instanceId: conn.from.legoId, legIndex: conn.from.legIndex }],
-          [{ instanceId: conn.to.legoId, legIndex: conn.to.legIndex }]
+          [{ instance_id: conn.from.legoId, leg_index: conn.from.leg_index }],
+          [{ instance_id: conn.to.legoId, leg_index: conn.to.leg_index }]
         );
       }
       // Case 2: Legos are in different components - merge them
@@ -301,8 +302,8 @@ export class TensorNetwork {
         // Conjoin the tensors
         const newTensor = comp1.tensor.conjoin(
           comp2.tensor,
-          [{ instanceId: conn.from.legoId, legIndex: conn.from.legIndex }],
-          [{ instanceId: conn.to.legoId, legIndex: conn.to.legIndex }]
+          [{ instance_id: conn.from.legoId, leg_index: conn.from.leg_index }],
+          [{ instance_id: conn.to.legoId, leg_index: conn.to.leg_index }]
         );
 
         // Update the first component with merged result
diff --git a/app/ui/src/lib/networkService.test.ts b/app/ui/src/lib/networkService.test.ts
new file mode 100644
index 00000000..8517c0c9
--- /dev/null
+++ b/app/ui/src/lib/networkService.test.ts
@@ -0,0 +1,58 @@
+import axios from "axios";
+
+import { NetworkService } from "./networkService";
+import * as cssNetworkResponse from "./test_data/css_network_response_bell_pair.json";
+
+jest.mock("axios");
+
+const mockedAxios = axios as jest.Mocked<typeof axios>;
+
+// Create mock functions outside so Jest can track them
+const mockAddDroppedLegos = jest.fn();
+const mockAddConnections = jest.fn();
+const mockAddOperation = jest.fn();
+const mockNewInstanceId = jest.fn(() => "1");
+
+jest.mock("../stores/canvasStateStore", () => ({
+  useCanvasStore: {
+    getState: jest.fn(() => ({
+      newInstanceId: mockNewInstanceId,
+      addDroppedLegos: mockAddDroppedLegos,
+      addConnections: mockAddConnections,
+      addOperation: mockAddOperation
+    }))
+  }
+}));
+
+jest.mock("../config/config");
+jest.mock("../features/auth/auth");
+
+export const getApiUrl = (endpoint: string) => `mocked-api-url/${endpoint}`;
+
+describe("NetworkService", () => {
+  beforeEach(() => {
+    jest.clearAllMocks();
+  });
+
+  describe("createCssTannerNetwork", () => {
+    // repro https://github.com/planqtn/planqtn/issues/108
+    it("should process the network response correctly", async () => {
+      mockedAxios.post.mockResolvedValue({ data: cssNetworkResponse });
+
+      const matrix = [
+        [1, 0, 0, 1],
+        [0, 1, 1, 0]
+      ]; // Example matrix
+
+      await NetworkService.createCssTannerNetwork(matrix);
+
+      expect(mockAddDroppedLegos).toHaveBeenCalled();
+      expect(mockAddConnections).toHaveBeenCalled();
+      expect(mockAddOperation).toHaveBeenCalledWith(
+        expect.objectContaining({
+          type: "add"
+        })
+      );
+    });
+  });
+});
diff --git a/app/ui/src/lib/networkService.ts b/app/ui/src/lib/networkService.ts
index fec94289..922e556a 100644
--- a/app/ui/src/lib/networkService.ts
+++ b/app/ui/src/lib/networkService.ts
@@ -2,12 +2,40 @@ import axios from "axios";
 import { Connection } from "../stores/connectionStore";
 import { useCanvasStore } from "../stores/canvasStateStore";
 import { config, getApiUrl } from "../config/config";
-import { getAccessToken } from "./auth";
+import { getAccessToken } from "../features/auth/auth";
 import { getAxiosErrorMessage } from "./errors";
 import { useModalStore } from "../stores/modalStore";
 import { DroppedLego } from "../stores/droppedLegoStore";
 import { LogicalPoint } from "../types/coordinates";
 
+interface ResponseLego {
+  instance_id: string;
+  type_id: string;
+  short_name: string;
+  description: string;
+  x: number;
+  y: number;
+  parity_check_matrix: number[][];
+  logical_legs: number[];
+  gauge_legs: number[];
+}
+
+interface ResponseConnection {
+  from: {
+    legoId: string;
+    leg_index: number;
+  };
+  to: {
+    legoId: string;
+    leg_index: number;
+  };
+}
+
+interface NetworkResponse {
+  legos: ResponseLego[];
+  connections: ResponseConnection[];
+}
+
 export class NetworkService {
   private static async requestTensorNetwork(
     matrix: number[][],
@@ -53,30 +81,44 @@ export class NetworkService {
 
   static async createCssTannerNetwork(matrix: number[][]): Promise<void> {
     const response = await this.requestTensorNetwork(matrix, "CSS_TANNER");
-    const { legos, connections } = response.data;
-
-    await this.processNetworkResponse(legos, connections, "CSS Tanner");
+    await this.processNetworkResponse(response.data, "CSS Tanner");
   }
 
   static async createTannerNetwork(matrix: number[][]): Promise<void> {
     const response = await this.requestTensorNetwork(matrix, "TANNER");
-    const { legos, connections } = response.data;
-
-    await this.processNetworkResponse(legos, connections, "Tanner");
+    await this.processNetworkResponse(response.data, "Tanner");
   }
 
   static async createMspNetwork(matrix: number[][]): Promise<void> {
     const response = await this.requestTensorNetwork(matrix, "MSP");
-    const { legos, connections } = response.data;
-
-    await this.processNetworkResponse(legos, connections, "MSP");
+    await this.processNetworkResponse(response.data, "MSP");
   }
 
   private static async processNetworkResponse(
-    legos: DroppedLego[],
-    connections: Connection[],
+    response: NetworkResponse,
     networkType: string
   ): Promise<void> {
+    const { legos: rawLegos, connections: rawConnections } = response;
+    const legos = rawLegos.map(
+      (lego: ResponseLego) =>
+        new DroppedLego(
+          {
+            type_id: lego.type_id,
+            name: lego.short_name,
+            short_name: lego.short_name,
+            description: lego.short_name,
+            parity_check_matrix: lego.parity_check_matrix,
+            logical_legs: lego.logical_legs,
+            gauge_legs: lego.gauge_legs
+          },
+          new LogicalPoint(lego.x, lego.y),
+          lego.instance_id
+        )
+    );
+    const connections = rawConnections.map(
+      (connection: ResponseConnection) =>
+        new Connection(connection.from, connection.to)
+    );
     const { addDroppedLegos, addConnections, addOperation } =
       useCanvasStore.getState();
 
@@ -128,23 +170,23 @@ export class NetworkService {
   ): DroppedLego[] {
     // Group legos by type
     const zNodes = legos.filter((lego: DroppedLego) =>
-      lego.shortName.startsWith("z")
+      lego.short_name.startsWith("z")
     );
     const qNodes = legos.filter((lego: DroppedLego) =>
-      lego.shortName.startsWith("q")
+      lego.short_name.startsWith("q")
     );
     const xNodes = legos.filter((lego: DroppedLego) =>
-      lego.shortName.startsWith("x")
+      lego.short_name.startsWith("x")
     );
 
     return legos.map((lego: DroppedLego) => {
       let nodesInRow: DroppedLego[];
       let y: number;
 
-      if (lego.shortName.startsWith("z")) {
+      if (lego.short_name.startsWith("z")) {
         nodesInRow = zNodes;
         y = 100; // Top row
-      } else if (lego.shortName.startsWith("q")) {
+      } else if (lego.short_name.startsWith("q")) {
         nodesInRow = qNodes;
         y = 250; // Middle row
       } else {
@@ -153,7 +195,7 @@ export class NetworkService {
       }
 
       const indexInRow = nodesInRow.findIndex(
-        (l) => l.instanceId === lego.instanceId
+        (l) => l.instance_id === lego.instance_id
       );
       const x =
         (canvasWidth - (nodesInRow.length - 1) * nodeSpacing) / 2 +
@@ -170,17 +212,17 @@ export class NetworkService {
   ): DroppedLego[] {
     // Group legos by type
     const checkNodes = legos.filter(
-      (lego: DroppedLego) => !lego.shortName.startsWith("q")
+      (lego: DroppedLego) => !lego.short_name.startsWith("q")
     );
     const qNodes = legos.filter((lego: DroppedLego) =>
-      lego.shortName.startsWith("q")
+      lego.short_name.startsWith("q")
     );
 
     return legos.map((lego: DroppedLego) => {
       let nodesInRow: DroppedLego[];
       let y: number;
 
-      if (lego.shortName.startsWith("q")) {
+      if (lego.short_name.startsWith("q")) {
         nodesInRow = qNodes;
         y = 300; // Bottom row
       } else {
@@ -189,7 +231,7 @@ export class NetworkService {
       }
 
       const indexInRow = nodesInRow.findIndex(
-        (l) => l.instanceId === lego.instanceId
+        (l) => l.instance_id === lego.instance_id
       );
       const x =
         (canvasWidth - (nodesInRow.length - 1) * nodeSpacing) / 2 +
diff --git a/app/ui/src/lib/test_data/css_network_response_bell_pair.json b/app/ui/src/lib/test_data/css_network_response_bell_pair.json
new file mode 100644
index 00000000..f7ad1489
--- /dev/null
+++ b/app/ui/src/lib/test_data/css_network_response_bell_pair.json
@@ -0,0 +1,293 @@
+{
+  "legos": [
+    {
+      "instance_id": "1",
+      "type_id": "stopper_i",
+      "short_name": "q0.id",
+      "description": "q0.id",
+      "x": 0,
+      "y": 0,
+      "parity_check_matrix": [[0, 0]],
+      "logical_legs": [],
+      "gauge_legs": []
+    },
+    {
+      "instance_id": "2",
+      "type_id": "h",
+      "short_name": "q0.h0",
+      "description": "q0.h0",
+      "x": 0,
+      "y": 0,
+      "parity_check_matrix": [
+        [1, 0, 0, 1],
+        [0, 1, 1, 0]
+      ],
+      "logical_legs": [],
+      "gauge_legs": []
+    },
+    {
+      "instance_id": "3",
+      "type_id": "x_rep_code",
+      "short_name": "q0.z",
+      "description": "q0.z",
+      "x": 0,
+      "y": 0,
+      "parity_check_matrix": [
+        [1, 1, 0, 0, 0, 0],
+        [0, 1, 1, 0, 0, 0],
+        [0, 0, 0, 1, 1, 1]
+      ],
+      "logical_legs": [],
+      "gauge_legs": []
+    },
+    {
+      "instance_id": "4",
+      "type_id": "h",
+      "short_name": "q0.h1",
+      "description": "q0.h1",
+      "x": 0,
+      "y": 0,
+      "parity_check_matrix": [
+        [1, 0, 0, 1],
+        [0, 1, 1, 0]
+      ],
+      "logical_legs": [],
+      "gauge_legs": []
+    },
+    {
+      "instance_id": "5",
+      "type_id": "x_rep_code",
+      "short_name": "q0.x",
+      "description": "q0.x",
+      "x": 0,
+      "y": 0,
+      "parity_check_matrix": [
+        [1, 1, 0, 0, 0, 0],
+        [0, 1, 1, 0, 0, 0],
+        [0, 0, 0, 1, 1, 1]
+      ],
+      "logical_legs": [],
+      "gauge_legs": []
+    },
+    {
+      "instance_id": "6",
+      "type_id": "stopper_i",
+      "short_name": "q1.id",
+      "description": "q1.id",
+      "x": 0,
+      "y": 0,
+      "parity_check_matrix": [[0, 0]],
+      "logical_legs": [],
+      "gauge_legs": []
+    },
+    {
+      "instance_id": "7",
+      "type_id": "h",
+      "short_name": "q1.h0",
+      "description": "q1.h0",
+      "x": 0,
+      "y": 0,
+      "parity_check_matrix": [
+        [1, 0, 0, 1],
+        [0, 1, 1, 0]
+      ],
+      "logical_legs": [],
+      "gauge_legs": []
+    },
+    {
+      "instance_id": "8",
+      "type_id": "x_rep_code",
+      "short_name": "q1.z",
+      "description": "q1.z",
+      "x": 0,
+      "y": 0,
+      "parity_check_matrix": [
+        [1, 1, 0, 0, 0, 0],
+        [0, 1, 1, 0, 0, 0],
+        [0, 0, 0, 1, 1, 1]
+      ],
+      "logical_legs": [],
+      "gauge_legs": []
+    },
+    {
+      "instance_id": "9",
+      "type_id": "h",
+      "short_name": "q1.h1",
+      "description": "q1.h1",
+      "x": 0,
+      "y": 0,
+      "parity_check_matrix": [
+        [1, 0, 0, 1],
+        [0, 1, 1, 0]
+      ],
+      "logical_legs": [],
+      "gauge_legs": []
+    },
+    {
+      "instance_id": "10",
+      "type_id": "x_rep_code",
+      "short_name": "q1.x",
+      "description": "q1.x",
+      "x": 0,
+      "y": 0,
+      "parity_check_matrix": [
+        [1, 1, 0, 0, 0, 0],
+        [0, 1, 1, 0, 0, 0],
+        [0, 0, 0, 1, 1, 1]
+      ],
+      "logical_legs": [],
+      "gauge_legs": []
+    },
+    {
+      "instance_id": "11",
+      "type_id": "z_rep_code",
+      "short_name": "x0",
+      "description": "x0",
+      "x": 0,
+      "y": 0,
+      "parity_check_matrix": [
+        [0, 0, 1, 1],
+        [1, 1, 0, 0]
+      ],
+      "logical_legs": [],
+      "gauge_legs": []
+    },
+    {
+      "instance_id": "12",
+      "type_id": "z_rep_code",
+      "short_name": "z0",
+      "description": "z0",
+      "x": 0,
+      "y": 0,
+      "parity_check_matrix": [
+        [0, 0, 1, 1],
+        [1, 1, 0, 0]
+      ],
+      "logical_legs": [],
+      "gauge_legs": []
+    }
+  ],
+  "connections": [
+    {
+      "from": {
+        "legoId": "1",
+        "leg_index": 0
+      },
+      "to": {
+        "legoId": "2",
+        "leg_index": 0
+      }
+    },
+    {
+      "from": {
+        "legoId": "2",
+        "leg_index": 1
+      },
+      "to": {
+        "legoId": "3",
+        "leg_index": 0
+      }
+    },
+    {
+      "from": {
+        "legoId": "4",
+        "leg_index": 0
+      },
+      "to": {
+        "legoId": "3",
+        "leg_index": 1
+      }
+    },
+    {
+      "from": {
+        "legoId": "4",
+        "leg_index": 1
+      },
+      "to": {
+        "legoId": "5",
+        "leg_index": 0
+      }
+    },
+    {
+      "from": {
+        "legoId": "6",
+        "leg_index": 0
+      },
+      "to": {
+        "legoId": "7",
+        "leg_index": 0
+      }
+    },
+    {
+      "from": {
+        "legoId": "7",
+        "leg_index": 1
+      },
+      "to": {
+        "legoId": "8",
+        "leg_index": 0
+      }
+    },
+    {
+      "from": {
+        "legoId": "9",
+        "leg_index": 0
+      },
+      "to": {
+        "legoId": "8",
+        "leg_index": 1
+      }
+    },
+    {
+      "from": {
+        "legoId": "9",
+        "leg_index": 1
+      },
+      "to": {
+        "legoId": "10",
+        "leg_index": 0
+      }
+    },
+    {
+      "from": {
+        "legoId": "11",
+        "leg_index": 0
+      },
+      "to": {
+        "legoId": "5",
+        "leg_index": 2
+      }
+    },
+    {
+      "from": {
+        "legoId": "11",
+        "leg_index": 1
+      },
+      "to": {
+        "legoId": "10",
+        "leg_index": 2
+      }
+    },
+    {
+      "from": {
+        "legoId": "12",
+        "leg_index": 0
+      },
+      "to": {
+        "legoId": "3",
+        "leg_index": 2
+      }
+    },
+    {
+      "from": {
+        "legoId": "12",
+        "leg_index": 1
+      },
+      "to": {
+        "legoId": "8",
+        "leg_index": 2
+      }
+    }
+  ],
+  "message": "Successfully created Tanner network"
+}
diff --git a/app/ui/src/lib/types.ts b/app/ui/src/lib/types.ts
index 11b7e8ed..65e5bc64 100644
--- a/app/ui/src/lib/types.ts
+++ b/app/ui/src/lib/types.ts
@@ -7,19 +7,6 @@ export enum PauliOperator {
   I = "I"
 }
 
-export interface LegoServerPayload {
-  instanceId: string;
-  id: string;
-  name: string;
-  shortName: string;
-  description?: string;
-  is_dynamic?: boolean;
-  parameters?: Record<string, unknown>;
-  parity_check_matrix: number[][];
-  logical_legs: number[];
-  gauge_legs: number[];
-}
-
 export interface TaskUpdateIterationStatus {
   desc: string;
   total_size: number;
diff --git a/app/ui/src/stores/canvasEventHandlingSlice.ts b/app/ui/src/stores/canvasEventHandlingSlice.ts
index 200bc68b..fb9c65bd 100644
--- a/app/ui/src/stores/canvasEventHandlingSlice.ts
+++ b/app/ui/src/stores/canvasEventHandlingSlice.ts
@@ -81,11 +81,11 @@ export const createCanvasEventHandlingSlice: StateCreator<
         lego_id: selectedDynamicLego.type_id,
         parameters
       });
-      const instanceId = newInstanceId();
+      const instance_id = newInstanceId();
       const newLego = new DroppedLego(
         dynamicLego,
         new LogicalPoint(pendingDropPosition.x, pendingDropPosition.y),
-        instanceId
+        instance_id
       );
       addDroppedLego(newLego);
       addOperation({
@@ -148,9 +148,9 @@ export const createCanvasEventHandlingSlice: StateCreator<
   },
 
   makeSpace: (center, radius, skipLegos, legosToCheck) => {
-    const skipIds = new Set(skipLegos.map((l) => l.instanceId));
+    const skipIds = new Set(skipLegos.map((l) => l.instance_id));
     return legosToCheck.map((lego) => {
-      if (skipIds.has(lego.instanceId)) return lego;
+      if (skipIds.has(lego.instance_id)) return lego;
       const dx = lego.logicalPosition.x - center.x;
       const dy = lego.logicalPosition.y - center.y;
       const distance = Math.sqrt(dx * dx + dy * dy);
@@ -193,15 +193,15 @@ export const createCanvasEventHandlingSlice: StateCreator<
 
     // Get max instance ID
     const maxInstanceId = Math.max(
-      ...droppedLegos.map((l) => parseInt(l.instanceId))
+      ...droppedLegos.map((l) => parseInt(l.instance_id))
     );
     const numLegs = lego.numberOfLegs;
 
     // Find any existing connections to the original lego
     const existingConnections = connections.filter(
       (conn) =>
-        conn.from.legoId === lego.instanceId ||
-        conn.to.legoId === lego.instanceId
+        conn.from.legoId === lego.instance_id ||
+        conn.to.legoId === lego.instance_id
     );
 
     try {
@@ -217,7 +217,7 @@ export const createCanvasEventHandlingSlice: StateCreator<
       const newLego: DroppedLego = new DroppedLego(
         { ...lego, parity_check_matrix: newLegoData.parity_check_matrix },
         lego.logicalPosition,
-        lego.instanceId
+        lego.instance_id
       );
 
       // Create a stopper based on the lego type
@@ -225,7 +225,7 @@ export const createCanvasEventHandlingSlice: StateCreator<
         {
           type_id: lego.type_id === "z_rep_code" ? "stopper_x" : "stopper_z",
           name: lego.type_id === "z_rep_code" ? "X Stopper" : "Z Stopper",
-          shortName: lego.type_id === "z_rep_code" ? "X" : "Z",
+          short_name: lego.type_id === "z_rep_code" ? "X" : "Z",
           description:
             lego.type_id === "z_rep_code" ? "X Stopper" : "Z Stopper",
           parity_check_matrix:
@@ -240,25 +240,26 @@ export const createCanvasEventHandlingSlice: StateCreator<
       // Create new connection to the stopper
       const newConnection: Connection = new Connection(
         {
-          legoId: lego.instanceId,
-          legIndex: numLegs // The new leg will be at index numLegs
+          legoId: lego.instance_id,
+          leg_index: numLegs // The new leg will be at index numLegs
         },
         {
-          legoId: stopperLego.instanceId,
-          legIndex: 0
+          legoId: stopperLego.instance_id,
+          leg_index: 0
         }
       );
 
       // Update the state
       const newLegos = [
-        ...droppedLegos.filter((l) => l.instanceId !== lego.instanceId),
+        ...droppedLegos.filter((l) => l.instance_id !== lego.instance_id),
         newLego,
         stopperLego
       ];
       const newConnections = [
         ...connections.filter(
           (c) =>
-            c.from.legoId !== lego.instanceId && c.to.legoId !== lego.instanceId
+            c.from.legoId !== lego.instance_id &&
+            c.to.legoId !== lego.instance_id
         ),
         ...existingConnections,
         newConnection
diff --git a/app/ui/src/stores/canvasStateStore.ts b/app/ui/src/stores/canvasStateStore.ts
index 2f25d6e6..f3fa092e 100644
--- a/app/ui/src/stores/canvasStateStore.ts
+++ b/app/ui/src/stores/canvasStateStore.ts
@@ -82,8 +82,8 @@ export const createGlobalTensorNetworkStore: StateCreator<
       state.connectedLegos = droppedLegos.filter((lego) =>
         connections.some(
           (connection) =>
-            connection.from.legoId === lego.instanceId ||
-            connection.to.legoId === lego.instanceId
+            connection.from.legoId === lego.instance_id ||
+            connection.to.legoId === lego.instance_id
         )
       );
     });
diff --git a/app/ui/src/stores/cloningSlice.ts b/app/ui/src/stores/cloningSlice.ts
index 298a8b7b..7c6f14a3 100644
--- a/app/ui/src/stores/cloningSlice.ts
+++ b/app/ui/src/stores/cloningSlice.ts
@@ -20,7 +20,9 @@ export const useCloningSlice: StateCreator<
     const connections = get().connections;
     const isSelected =
       tensorNetwork &&
-      tensorNetwork?.legos.some((l) => l.instanceId === clickedLego.instanceId);
+      tensorNetwork?.legos.some(
+        (l) => l.instance_id === clickedLego.instance_id
+      );
 
     const cloneOffset = new LogicalPoint(20, 20);
     // Check if we're cloning multiple legos
@@ -33,9 +35,9 @@ export const useCloningSlice: StateCreator<
     const instanceIdMap = new Map<string, string>();
     const newLegos = legosToClone.map((l, idx) => {
       const newId = String(startingId + idx);
-      instanceIdMap.set(l.instanceId, newId);
+      instanceIdMap.set(l.instance_id, newId);
       return l.with({
-        instanceId: newId,
+        instance_id: newId,
         logicalPosition: l.logicalPosition.plus(cloneOffset)
       });
     });
@@ -44,19 +46,19 @@ export const useCloningSlice: StateCreator<
     const newConnections = connections
       .filter(
         (conn) =>
-          legosToClone.some((l) => l.instanceId === conn.from.legoId) &&
-          legosToClone.some((l) => l.instanceId === conn.to.legoId)
+          legosToClone.some((l) => l.instance_id === conn.from.legoId) &&
+          legosToClone.some((l) => l.instance_id === conn.to.legoId)
       )
       .map(
         (conn) =>
           new Connection(
             {
               legoId: instanceIdMap.get(conn.from.legoId)!,
-              legIndex: conn.from.legIndex
+              leg_index: conn.from.leg_index
             },
             {
               legoId: instanceIdMap.get(conn.to.legoId)!,
-              legIndex: conn.to.legIndex
+              leg_index: conn.to.leg_index
             }
           )
       );
@@ -66,21 +68,21 @@ export const useCloningSlice: StateCreator<
     get().addConnections(newConnections);
 
     // Set up drag state for the group
-    const positions: { [instanceId: string]: LogicalPoint } = {};
+    const positions: { [instance_id: string]: LogicalPoint } = {};
     newLegos.forEach((l) => {
-      positions[l.instanceId] = l.logicalPosition;
+      positions[l.instance_id] = l.logicalPosition;
     });
 
     if (newLegos.length > 1) {
       get().setGroupDragState({
-        legoInstanceIds: newLegos.map((l) => l.instanceId),
+        legoInstanceIds: newLegos.map((l) => l.instance_id),
         originalPositions: positions
       });
     }
 
     get().setLegoDragState({
       draggingStage: DraggingStage.MAYBE_DRAGGING,
-      draggedLegoInstanceId: newLegos[0].instanceId,
+      draggedLegoInstanceId: newLegos[0].instance_id,
       startMouseWindowPoint: new WindowPoint(x, y),
       startLegoLogicalPoint: clickedLego.logicalPosition.plus(
         new LogicalPoint(20, 20)
diff --git a/app/ui/src/stores/connectionStore.ts b/app/ui/src/stores/connectionStore.ts
index 1ffce38c..2b7da314 100644
--- a/app/ui/src/stores/connectionStore.ts
+++ b/app/ui/src/stores/connectionStore.ts
@@ -5,34 +5,34 @@ export class Connection {
   constructor(
     public from: {
       legoId: string;
-      legIndex: number;
+      leg_index: number;
     },
     public to: {
       legoId: string;
-      legIndex: number;
+      leg_index: number;
     }
   ) {}
 
   public equals(other: Connection): boolean {
     return (
       (this.from.legoId === other.from.legoId &&
-        this.from.legIndex === other.from.legIndex &&
+        this.from.leg_index === other.from.leg_index &&
         this.to.legoId === other.to.legoId &&
-        this.to.legIndex === other.to.legIndex) ||
+        this.to.leg_index === other.to.leg_index) ||
       (this.from.legoId === other.to.legoId &&
-        this.from.legIndex === other.to.legIndex &&
+        this.from.leg_index === other.to.leg_index &&
         this.to.legoId === other.from.legoId &&
-        this.to.legIndex === other.from.legIndex)
+        this.to.leg_index === other.from.leg_index)
     );
   }
 
   public containsLego(legoId: string): boolean {
     return this.from.legoId === legoId || this.to.legoId === legoId;
   }
-  public containsLeg(legoId: string, legIndex: number): boolean {
+  public containsLeg(legoId: string, leg_index: number): boolean {
     return (
-      (this.from.legoId === legoId && this.from.legIndex === legIndex) ||
-      (this.to.legoId === legoId && this.to.legIndex === legIndex)
+      (this.from.legoId === legoId && this.from.leg_index === leg_index) ||
+      (this.to.legoId === legoId && this.to.leg_index === leg_index)
     );
   }
 }
@@ -42,7 +42,7 @@ export interface ConnectionSlice {
   setConnections: (connections: Connection[]) => void;
   addConnections: (connections: Connection[]) => void;
   removeConnections: (connections: Connection[]) => void;
-  isLegConnected: (legoId: string, legIndex: number) => boolean;
+  isLegConnected: (legoId: string, leg_index: number) => boolean;
 }
 
 export const createConnectionsSlice: StateCreator<
@@ -60,8 +60,8 @@ export const createConnectionsSlice: StateCreator<
       state.connectedLegos = state.droppedLegos.filter((lego) =>
         state.connections.some(
           (connection) =>
-            connection.from.legoId === lego.instanceId ||
-            connection.to.legoId === lego.instanceId
+            connection.from.legoId === lego.instance_id ||
+            connection.to.legoId === lego.instance_id
         )
       );
     });
@@ -76,8 +76,8 @@ export const createConnectionsSlice: StateCreator<
       state.connectedLegos = state.droppedLegos.filter((lego) =>
         state.connections.some(
           (connection) =>
-            connection.from.legoId === lego.instanceId ||
-            connection.to.legoId === lego.instanceId
+            connection.from.legoId === lego.instance_id ||
+            connection.to.legoId === lego.instance_id
         )
       );
     });
@@ -94,8 +94,8 @@ export const createConnectionsSlice: StateCreator<
       state.connectedLegos = state.droppedLegos.filter((lego) =>
         state.connections.some(
           (connection) =>
-            connection.from.legoId === lego.instanceId ||
-            connection.to.legoId === lego.instanceId
+            connection.from.legoId === lego.instance_id ||
+            connection.to.legoId === lego.instance_id
         )
       );
     });
@@ -104,17 +104,17 @@ export const createConnectionsSlice: StateCreator<
     get().updateEncodedCanvasState();
   },
 
-  isLegConnected: (legoId, legIndex) => {
+  isLegConnected: (legoId, leg_index) => {
     return get().connections.some((connection) => {
       if (
         connection.from.legoId === legoId &&
-        connection.from.legIndex === legIndex
+        connection.from.leg_index === leg_index
       ) {
         return true;
       }
       if (
         connection.to.legoId === legoId &&
-        connection.to.legIndex === legIndex
+        connection.to.leg_index === leg_index
       ) {
         return true;
       }
diff --git a/app/ui/src/stores/droppedLego.test.ts b/app/ui/src/stores/droppedLego.test.ts
index 11b8a0dd..aed288f1 100644
--- a/app/ui/src/stores/droppedLego.test.ts
+++ b/app/ui/src/stores/droppedLego.test.ts
@@ -7,7 +7,7 @@ describe("DroppedLego", () => {
       {
         type_id: "1",
         name: "Test Lego",
-        shortName: "TL",
+        short_name: "TL",
         description: "Test Lego",
         parity_check_matrix: [
           [1, 0],
@@ -22,7 +22,7 @@ describe("DroppedLego", () => {
 
     expect(lego.type_id).toBe("1");
     expect(lego.name).toBe("Test Lego");
-    expect(lego.shortName).toBe("TL");
+    expect(lego.short_name).toBe("TL");
     expect(lego.description).toBe("Test Lego");
     expect(lego.parity_check_matrix).toEqual([
       [1, 0],
@@ -37,7 +37,7 @@ describe("DroppedLego", () => {
       {
         type_id: "1",
         name: "Test Lego",
-        shortName: "TL",
+        short_name: "TL",
         description: "Test Lego",
         parity_check_matrix: [
           [1, 0],
@@ -50,13 +50,13 @@ describe("DroppedLego", () => {
       "1",
       {
         logicalPosition: new LogicalPoint(10, 10),
-        instanceId: "2"
+        instance_id: "2"
       }
     );
 
     expect(lego.type_id).toBe("1");
     expect(lego.name).toBe("Test Lego");
-    expect(lego.shortName).toBe("TL");
+    expect(lego.short_name).toBe("TL");
     expect(lego.description).toBe("Test Lego");
     expect(lego.selectedMatrixRows).toEqual([]);
     expect(lego.parity_check_matrix).toEqual([
@@ -68,16 +68,16 @@ describe("DroppedLego", () => {
     // we ignore the override for mandatory parameters passed to the constructor
     expect(lego.logicalPosition.x).toBe(0);
     expect(lego.logicalPosition.y).toBe(0);
-    expect(lego.instanceId).toBe("1");
+    expect(lego.instance_id).toBe("1");
 
     // However, when used with the with method, the override is applied
     const lego2 = lego.with({
       logicalPosition: new LogicalPoint(10, 10),
-      instanceId: "2"
+      instance_id: "2"
     });
     expect(lego2.logicalPosition.x).toBe(10);
     expect(lego2.logicalPosition.y).toBe(10);
-    expect(lego2.instanceId).toBe("2");
+    expect(lego2.instance_id).toBe("2");
   });
 
   it("should create a new lego with the correct properties when overridden with the with method", () => {
@@ -85,7 +85,7 @@ describe("DroppedLego", () => {
       {
         type_id: "1",
         name: "Test Lego",
-        shortName: "TL",
+        short_name: "TL",
         description: "Test Lego",
         parity_check_matrix: [
           [1, 0],
@@ -105,11 +105,11 @@ describe("DroppedLego", () => {
 
     const lego2 = lego.with({
       logicalPosition: new LogicalPoint(10, 10),
-      instanceId: "2"
+      instance_id: "2"
     });
     expect(lego2.logicalPosition.x).toBe(10);
     expect(lego2.logicalPosition.y).toBe(10);
-    expect(lego2.instanceId).toBe("2");
+    expect(lego2.instance_id).toBe("2");
     expect(lego2.selectedMatrixRows).toEqual([0, 1]);
   });
 });
diff --git a/app/ui/src/stores/droppedLegoEventsSlice.ts b/app/ui/src/stores/droppedLegoEventsSlice.ts
index 1695b234..5d939e4c 100644
--- a/app/ui/src/stores/droppedLegoEventsSlice.ts
+++ b/app/ui/src/stores/droppedLegoEventsSlice.ts
@@ -12,7 +12,7 @@ export interface DroppedLegoClickHandlerSlice {
     metaKey: boolean
   ) => void;
   handleLegoMouseDown: (
-    instanceId: string,
+    instance_id: string,
     x: number,
     y: number,
     shiftKey: boolean
@@ -44,19 +44,19 @@ export const useDroppedLegoClickHandlerSlice: StateCreator<
         // Handle Ctrl+click for toggling selection
         // Find the current version of the lego from droppedLegos to avoid stale state
         const currentLego = get().droppedLegos.find(
-          (l) => l.instanceId === lego.instanceId
+          (l) => l.instance_id === lego.instance_id
         );
         if (!currentLego) return;
 
         const tensorNetwork = get().tensorNetwork;
         if (tensorNetwork) {
           const isSelected = tensorNetwork.legos.some(
-            (l) => l.instanceId === currentLego.instanceId
+            (l) => l.instance_id === currentLego.instance_id
           );
           if (isSelected) {
             // Remove lego from tensor network
             const newLegos = tensorNetwork.legos.filter(
-              (l) => l.instanceId !== currentLego.instanceId
+              (l) => l.instance_id !== currentLego.instance_id
             );
 
             if (newLegos.length === 0) {
@@ -64,8 +64,8 @@ export const useDroppedLegoClickHandlerSlice: StateCreator<
             } else {
               const newConnections = tensorNetwork.connections.filter(
                 (conn) =>
-                  conn.from.legoId !== currentLego.instanceId &&
-                  conn.to.legoId !== currentLego.instanceId
+                  conn.from.legoId !== currentLego.instance_id &&
+                  conn.to.legoId !== currentLego.instance_id
               );
               get().setTensorNetwork(
                 new TensorNetwork({
@@ -79,8 +79,8 @@ export const useDroppedLegoClickHandlerSlice: StateCreator<
             const newLegos = [...tensorNetwork.legos, currentLego];
             const newConnections = get().connections.filter(
               (conn) =>
-                newLegos.some((l) => l.instanceId === conn.from.legoId) &&
-                newLegos.some((l) => l.instanceId === conn.to.legoId)
+                newLegos.some((l) => l.instance_id === conn.from.legoId) &&
+                newLegos.some((l) => l.instance_id === conn.to.legoId)
             );
 
             get().setTensorNetwork(
@@ -99,14 +99,14 @@ export const useDroppedLegoClickHandlerSlice: StateCreator<
       } else {
         // Regular click behavior
         const isCurrentlySelected = get().tensorNetwork?.legos.some(
-          (l) => l.instanceId === lego.instanceId
+          (l) => l.instance_id === lego.instance_id
         );
 
         if (isCurrentlySelected && get().tensorNetwork?.legos.length === 1) {
           // Second click on same already selected lego - expand to connected component
           // Find the current version of the lego from droppedLegos to avoid stale state
           const currentLego = get().droppedLegos.find(
-            (l) => l.instanceId === lego.instanceId
+            (l) => l.instance_id === lego.instance_id
           );
           if (!currentLego) return;
 
@@ -123,7 +123,7 @@ export const useDroppedLegoClickHandlerSlice: StateCreator<
           // First click on unselected lego or clicking different lego - select just this lego
           // Find the current version of the lego from droppedLegos to avoid stale state
           const currentLego = get().droppedLegos.find(
-            (l) => l.instanceId === lego.instanceId
+            (l) => l.instance_id === lego.instance_id
           );
           if (!currentLego) return;
 
@@ -136,34 +136,34 @@ export const useDroppedLegoClickHandlerSlice: StateCreator<
   },
 
   handleLegoMouseDown: (
-    instanceId: string,
+    instance_id: string,
     x: number,
     y: number,
     shiftKey: boolean
   ) => {
     // Get lego from store instead of passed prop
-    const lego = get().droppedLegos.find((l) => l.instanceId === instanceId);
+    const lego = get().droppedLegos.find((l) => l.instance_id === instance_id);
     if (!lego) return;
 
     if (shiftKey) {
       get().handleClone(lego, x, y);
     } else {
       const isPartOfSelection = get().tensorNetwork?.legos.some(
-        (l) => l.instanceId === lego.instanceId
+        (l) => l.instance_id === lego.instance_id
       );
 
       if (isPartOfSelection && (get().tensorNetwork?.legos.length || 0) > 1) {
         // Dragging a selected lego - move the whole group
         const selectedLegos = get().tensorNetwork?.legos || [];
         const currentPositions: {
-          [instanceId: string]: LogicalPoint;
+          [instance_id: string]: LogicalPoint;
         } = {};
         selectedLegos.forEach((l) => {
-          currentPositions[l.instanceId] = l.logicalPosition;
+          currentPositions[l.instance_id] = l.logicalPosition;
         });
 
         get().setGroupDragState({
-          legoInstanceIds: selectedLegos.map((l) => l.instanceId),
+          legoInstanceIds: selectedLegos.map((l) => l.instance_id),
           originalPositions: currentPositions
         });
       } else {
@@ -176,7 +176,7 @@ export const useDroppedLegoClickHandlerSlice: StateCreator<
       // not dragging yet but the index is set, so we can start dragging when the mouse moves
       get().setLegoDragState({
         draggingStage: DraggingStage.MAYBE_DRAGGING,
-        draggedLegoInstanceId: lego.instanceId,
+        draggedLegoInstanceId: lego.instance_id,
         startMouseWindowPoint: new WindowPoint(x, y),
         startLegoLogicalPoint: lego.logicalPosition
       });
diff --git a/app/ui/src/stores/droppedLegoLegEventsSlice.ts b/app/ui/src/stores/droppedLegoLegEventsSlice.ts
index 68a2c600..667de064 100644
--- a/app/ui/src/stores/droppedLegoLegEventsSlice.ts
+++ b/app/ui/src/stores/droppedLegoLegEventsSlice.ts
@@ -9,12 +9,12 @@ import { WindowPoint } from "../types/coordinates";
 export interface DroppedLegoLegEventsSlice {
   handleLegMouseDown: (
     legoId: string,
-    legIndex: number,
+    leg_index: number,
     mouseWindowPoint: WindowPoint
   ) => void;
 
-  handleLegClick: (legoId: string, legIndex: number) => void;
-  handleLegMouseUp: (legoId: string, legIndex: number) => void;
+  handleLegClick: (legoId: string, leg_index: number) => void;
+  handleLegMouseUp: (legoId: string, leg_index: number) => void;
 }
 
 export const useLegoLegEventsSlice: StateCreator<
@@ -23,41 +23,41 @@ export const useLegoLegEventsSlice: StateCreator<
   [],
   DroppedLegoLegEventsSlice
 > = (_, get) => ({
-  handleLegMouseDown: (legoId, legIndex, mouseWindowPoint) => {
+  handleLegMouseDown: (legoId, leg_index, mouseWindowPoint) => {
     get().temporarilyConnectLego(legoId);
 
     get().setLegDragState({
       isDragging: true,
       legoId,
-      legIndex,
+      leg_index,
       startMouseWindowPoint: mouseWindowPoint,
       currentMouseWindowPoint: mouseWindowPoint
     });
   },
 
-  handleLegClick: (legoId, legIndex) => {
+  handleLegClick: (legoId, leg_index) => {
     // Find the lego that was clicked
     const clickedLego = get().droppedLegos.find(
-      (lego) => lego.instanceId === legoId
+      (lego) => lego.instance_id === legoId
     );
     if (!clickedLego) return;
     const numQubits = clickedLego.numberOfLegs;
     const h = clickedLego.parity_check_matrix;
     const existingPushedLeg = clickedLego.selectedMatrixRows?.find(
-      (row) => h[row][legIndex] == 1 || h[row][legIndex + numQubits] == 1
+      (row) => h[row][leg_index] == 1 || h[row][leg_index + numQubits] == 1
     );
     const currentOperator = existingPushedLeg
-      ? h[existingPushedLeg][legIndex] == 1
+      ? h[existingPushedLeg][leg_index] == 1
         ? PauliOperator.X
         : PauliOperator.Z
       : PauliOperator.I;
 
     // Find available operators in parity check matrix for this leg
     const hasX = clickedLego.parity_check_matrix.some(
-      (row) => row[legIndex] === 1 && row[legIndex + numQubits] === 0
+      (row) => row[leg_index] === 1 && row[leg_index + numQubits] === 0
     );
     const hasZ = clickedLego.parity_check_matrix.some(
-      (row) => row[legIndex] === 0 && row[legIndex + numQubits] === 1
+      (row) => row[leg_index] === 0 && row[leg_index + numQubits] === 1
     );
 
     // Cycle through operators only if they exist in matrix
@@ -80,13 +80,13 @@ export const useLegoLegEventsSlice: StateCreator<
         nextOperator = PauliOperator.I;
     }
 
-    // Find the first row in parity check matrix that matches currentOperator on legIndex
+    // Find the first row in parity check matrix that matches currentOperator on leg_index
     const baseRepresentative =
       clickedLego.parity_check_matrix.find((row) => {
         if (nextOperator === PauliOperator.X) {
-          return row[legIndex] === 1 && row[legIndex + numQubits] === 0;
+          return row[leg_index] === 1 && row[leg_index + numQubits] === 0;
         } else if (nextOperator === PauliOperator.Z) {
-          return row[legIndex] === 0 && row[legIndex + numQubits] === 1;
+          return row[leg_index] === 0 && row[leg_index + numQubits] === 1;
         }
         return false;
       }) || new Array(2 * numQubits).fill(0);
@@ -111,7 +111,7 @@ export const useLegoLegEventsSlice: StateCreator<
 
     // Update droppedLegos by replacing the old lego with the new one
     const newDroppedLegos = get().droppedLegos.map((lego) =>
-      lego.instanceId === legoId ? updatedLego : lego
+      lego.instance_id === legoId ? updatedLego : lego
     );
     get().setDroppedLegos(newDroppedLegos);
 
@@ -123,7 +123,7 @@ export const useLegoLegEventsSlice: StateCreator<
     );
   },
 
-  handleLegMouseUp: (legoId, legIndex) => {
+  handleLegMouseUp: (legoId, leg_index) => {
     const { legDragState, setLegDragState } = get();
     const {
       connections,
@@ -131,7 +131,7 @@ export const useLegoLegEventsSlice: StateCreator<
       addOperation,
       addConnections
     } = get();
-    const lego = get().droppedLegos.find((lego) => lego.instanceId === legoId);
+    const lego = get().droppedLegos.find((lego) => lego.instance_id === legoId);
     if (!lego) return;
 
     if (!legDragState) return;
@@ -139,20 +139,20 @@ export const useLegoLegEventsSlice: StateCreator<
     const isSourceLegConnected = get().connections.some(
       (conn) =>
         (conn.from.legoId === legDragState.legoId &&
-          conn.from.legIndex === legDragState.legIndex) ||
+          conn.from.leg_index === legDragState.leg_index) ||
         (conn.to.legoId === legDragState.legoId &&
-          conn.to.legIndex === legDragState.legIndex)
+          conn.to.leg_index === legDragState.leg_index)
     );
     const isTargetLegConnected = connections.some(
       (conn) =>
-        (conn.from.legoId === lego.instanceId &&
-          conn.from.legIndex === legIndex) ||
-        (conn.to.legoId === lego.instanceId && conn.to.legIndex === legIndex)
+        (conn.from.legoId === lego.instance_id &&
+          conn.from.leg_index === leg_index) ||
+        (conn.to.legoId === lego.instance_id && conn.to.leg_index === leg_index)
     );
 
     if (
-      lego.instanceId === legDragState.legoId &&
-      legIndex === legDragState.legIndex
+      lego.instance_id === legDragState.legoId &&
+      leg_index === legDragState.leg_index
     ) {
       setLegDragState(null);
       updateLegoConnectivity(legDragState.legoId);
@@ -172,24 +172,24 @@ export const useLegoLegEventsSlice: StateCreator<
     const connectionExists = connections.some(
       (conn) =>
         (conn.from.legoId === legDragState.legoId &&
-          conn.from.legIndex === legDragState.legIndex &&
-          conn.to.legoId === lego.instanceId &&
-          conn.to.legIndex === legIndex) ||
-        (conn.from.legoId === lego.instanceId &&
-          conn.from.legIndex === legIndex &&
+          conn.from.leg_index === legDragState.leg_index &&
+          conn.to.legoId === lego.instance_id &&
+          conn.to.leg_index === leg_index) ||
+        (conn.from.legoId === lego.instance_id &&
+          conn.from.leg_index === leg_index &&
           conn.to.legoId === legDragState.legoId &&
-          conn.to.legIndex === legDragState.legIndex)
+          conn.to.leg_index === legDragState.leg_index)
     );
 
     if (!connectionExists) {
       const newConnection = new Connection(
         {
           legoId: legDragState.legoId,
-          legIndex: legDragState.legIndex
+          leg_index: legDragState.leg_index
         },
         {
-          legoId: lego.instanceId,
-          legIndex: legIndex
+          legoId: lego.instance_id,
+          leg_index: leg_index
         }
       );
 
diff --git a/app/ui/src/stores/droppedLegoStore.ts b/app/ui/src/stores/droppedLegoStore.ts
index b59d49ac..43b7468c 100644
--- a/app/ui/src/stores/droppedLegoStore.ts
+++ b/app/ui/src/stores/droppedLegoStore.ts
@@ -10,53 +10,53 @@ export function recalculateLegoStyle(lego: DroppedLego): void {
 
 export function createXRepCodeLego(
   canvasPosition: LogicalPoint,
-  instanceId: string,
+  instance_id: string,
   d: number = 3
 ): DroppedLego {
   return new DroppedLego(
     {
       type_id: "x_rep_code",
       name: "X Repetition Code",
-      shortName: "XRep",
+      short_name: "XRep",
       description: "X Repetition Code",
       parity_check_matrix: Legos.x_rep_code(d),
       logical_legs: [],
       gauge_legs: []
     },
     canvasPosition,
-    instanceId
+    instance_id
   );
 }
 
 export function createZRepCodeLego(
   canvasPosition: LogicalPoint,
-  instanceId: string,
+  instance_id: string,
   d: number = 3
 ): DroppedLego {
   return new DroppedLego(
     {
       type_id: "z_rep_code",
       name: "Z Repetition Code",
-      shortName: "ZRep",
+      short_name: "ZRep",
       description: "Z Repetition Code",
       parity_check_matrix: Legos.z_rep_code(d),
       logical_legs: [],
       gauge_legs: []
     },
     canvasPosition,
-    instanceId
+    instance_id
   );
 }
 
 export function createHadamardLego(
   canvasPosition: LogicalPoint,
-  instanceId: string
+  instance_id: string
 ): DroppedLego {
   return new DroppedLego(
     {
       type_id: "h",
       name: "Hadamard",
-      shortName: "H",
+      short_name: "H",
       description: "Hadamard",
       parity_check_matrix: [
         [1, 0, 0, 1],
@@ -66,14 +66,14 @@ export function createHadamardLego(
       gauge_legs: []
     },
     canvasPosition,
-    instanceId
+    instance_id
   );
 }
 
 export interface LegoPiece {
   type_id: string;
   name: string;
-  shortName: string;
+  short_name: string;
   description: string;
   is_dynamic?: boolean;
   parameters?: Record<string, unknown>;
@@ -85,14 +85,14 @@ export interface LegoPiece {
 export class DroppedLego implements LegoPiece {
   public type_id: string;
   public name: string;
-  public shortName: string;
+  public short_name: string;
   public description: string;
   public parity_check_matrix: number[][];
   public logical_legs: number[];
   public gauge_legs: number[];
   public is_dynamic?: boolean;
   public parameters?: Record<string, unknown>;
-  public instanceId: string;
+  public instance_id: string;
   private _selectedMatrixRows: number[];
   public alwaysShowLegs: boolean;
   public style: LegoStyle;
@@ -102,13 +102,13 @@ export class DroppedLego implements LegoPiece {
     lego: LegoPiece,
     // mandatory parameters
     canvasPosition: LogicalPoint,
-    instanceId: string,
+    instance_id: string,
     // optional overrides
     overrides: Partial<DroppedLego> = {}
   ) {
     this.type_id = lego.type_id;
     this.name = lego.name;
-    this.shortName = overrides.shortName || lego.shortName;
+    this.short_name = overrides.short_name || lego.short_name;
     this.description = overrides.description || lego.description;
     this.parity_check_matrix =
       overrides.parity_check_matrix || lego.parity_check_matrix;
@@ -117,7 +117,7 @@ export class DroppedLego implements LegoPiece {
     this.is_dynamic = lego.is_dynamic;
     this.parameters = lego.parameters;
     this.logicalPosition = canvasPosition;
-    this.instanceId = instanceId;
+    this.instance_id = instance_id;
     this._selectedMatrixRows = overrides.selectedMatrixRows || [];
     this.alwaysShowLegs = overrides.alwaysShowLegs || false;
 
@@ -132,7 +132,7 @@ export class DroppedLego implements LegoPiece {
     return new DroppedLego(
       this,
       overrides.logicalPosition || this.logicalPosition,
-      overrides.instanceId || this.instanceId,
+      overrides.instance_id || this.instance_id,
       {
         selectedMatrixRows:
           overrides.selectedMatrixRows || this.selectedMatrixRows,
@@ -158,14 +158,14 @@ export interface DroppedLegosSlice {
   droppedLegos: DroppedLego[];
   connectedLegos: DroppedLego[];
 
-  temporarilyConnectLego: (instanceId: string) => void;
-  updateLegoConnectivity: (instanceId: string) => void;
+  temporarilyConnectLego: (instance_id: string) => void;
+  updateLegoConnectivity: (instance_id: string) => void;
 
   setDroppedLegos: (legos: DroppedLego[]) => void;
   addDroppedLego: (lego: DroppedLego) => void;
   addDroppedLegos: (legos: DroppedLego[]) => void;
-  removeDroppedLego: (instanceId: string) => void;
-  updateDroppedLego: (instanceId: string, updates: DroppedLego) => void;
+  removeDroppedLego: (instance_id: string) => void;
+  updateDroppedLego: (instance_id: string, updates: DroppedLego) => void;
   updateDroppedLegos: (legos: DroppedLego[]) => void;
   moveDroppedLegos: (legos: DroppedLego[]) => void;
   removeDroppedLegos: (instanceIds: string[]) => void;
@@ -179,7 +179,7 @@ export function newInstanceId(droppedLegos: DroppedLego[]): string {
     return "1";
   }
   return String(
-    Math.max(...droppedLegos.map((lego) => parseInt(lego.instanceId))) + 1
+    Math.max(...droppedLegos.map((lego) => parseInt(lego.instance_id))) + 1
   );
 }
 
@@ -195,29 +195,29 @@ export const createLegoSlice: StateCreator<
     return newInstanceId(get().droppedLegos);
   },
 
-  temporarilyConnectLego: (instanceId: string) => {
+  temporarilyConnectLego: (instance_id: string) => {
     set((state) => {
       if (
-        !state.connectedLegos.find((lego) => lego.instanceId === instanceId)
+        !state.connectedLegos.find((lego) => lego.instance_id === instance_id)
       ) {
         state.connectedLegos.push(
-          state.droppedLegos.find((lego) => lego.instanceId === instanceId)!
+          state.droppedLegos.find((lego) => lego.instance_id === instance_id)!
         );
       }
     });
   },
 
-  updateLegoConnectivity: (instanceId: string) => {
+  updateLegoConnectivity: (instance_id: string) => {
     set((state) => {
       if (
         !get().connections.some(
           (connection) =>
-            connection.from.legoId === instanceId ||
-            connection.to.legoId === instanceId
+            connection.from.legoId === instance_id ||
+            connection.to.legoId === instance_id
         )
       ) {
         state.connectedLegos = state.connectedLegos.filter(
-          (lego) => lego.instanceId !== instanceId
+          (lego) => lego.instance_id !== instance_id
         );
       }
     });
@@ -228,8 +228,8 @@ export const createLegoSlice: StateCreator<
       state.connectedLegos = legos.filter((lego) =>
         get().connections.some(
           (connection) =>
-            connection.from.legoId === lego.instanceId ||
-            connection.to.legoId === lego.instanceId
+            connection.from.legoId === lego.instance_id ||
+            connection.to.legoId === lego.instance_id
         )
       );
     });
@@ -244,9 +244,9 @@ export const createLegoSlice: StateCreator<
       state.droppedLegos.push(lego);
     });
     // Initialize leg hide states for the new lego
-    get().initializeLegHideStates(lego.instanceId, lego.numberOfLegs);
+    get().initializeLegHideStates(lego.instance_id, lego.numberOfLegs);
     // Initialize leg connection states for the new lego
-    get().initializeLegConnectionStates(lego.instanceId, lego.numberOfLegs);
+    get().initializeLegConnectionStates(lego.instance_id, lego.numberOfLegs);
     // Update all leg hide states to account for the new lego
     get().updateAllLegHideStates();
     get().updateEncodedCanvasState();
@@ -258,8 +258,8 @@ export const createLegoSlice: StateCreator<
     });
     // Initialize leg hide states for new legos
     legos.forEach((lego) => {
-      get().initializeLegHideStates(lego.instanceId, lego.numberOfLegs);
-      get().initializeLegConnectionStates(lego.instanceId, lego.numberOfLegs);
+      get().initializeLegHideStates(lego.instance_id, lego.numberOfLegs);
+      get().initializeLegConnectionStates(lego.instance_id, lego.numberOfLegs);
     });
     // Update all leg hide states to account for the new legos
     get().updateAllLegHideStates();
@@ -267,23 +267,25 @@ export const createLegoSlice: StateCreator<
     get().updateEncodedCanvasState();
   },
 
-  removeDroppedLego: (instanceId: string) => {
+  removeDroppedLego: (instance_id: string) => {
     set((state) => {
       state.droppedLegos = state.droppedLegos.filter(
-        (lego) => lego.instanceId !== instanceId
+        (lego) => lego.instance_id !== instance_id
       );
-      if (state.connectedLegos.some((lego) => lego.instanceId === instanceId)) {
+      if (
+        state.connectedLegos.some((lego) => lego.instance_id === instance_id)
+      ) {
         state.connectedLegos = state.connectedLegos.filter(
-          (lego) => lego.instanceId !== instanceId
+          (lego) => lego.instance_id !== instance_id
         );
       }
     });
     // Remove leg hide states for the deleted lego
-    get().removeLegHideStates(instanceId);
+    get().removeLegHideStates(instance_id);
     // Remove leg connection states for the deleted lego
-    get().removeLegConnectionStates(instanceId);
+    get().removeLegConnectionStates(instance_id);
     // Remove lego from connection map
-    get().removeLegoFromConnectionMap(instanceId);
+    get().removeLegoFromConnectionMap(instance_id);
     // Update all leg hide states to account for the removed lego
     get().updateAllLegHideStates();
 
@@ -293,23 +295,23 @@ export const createLegoSlice: StateCreator<
   removeDroppedLegos: (instanceIds: string[]) => {
     set((state) => {
       state.droppedLegos = state.droppedLegos.filter(
-        (lego) => !instanceIds.includes(lego.instanceId)
+        (lego) => !instanceIds.includes(lego.instance_id)
       );
       if (
         state.connectedLegos.some((lego) =>
-          instanceIds.includes(lego.instanceId)
+          instanceIds.includes(lego.instance_id)
         )
       ) {
         state.connectedLegos = state.connectedLegos.filter(
-          (lego) => !instanceIds.includes(lego.instanceId)
+          (lego) => !instanceIds.includes(lego.instance_id)
         );
       }
     });
     // Remove leg hide states for deleted legos
-    instanceIds.forEach((instanceId) => {
-      get().removeLegHideStates(instanceId);
-      get().removeLegConnectionStates(instanceId);
-      get().removeLegoFromConnectionMap(instanceId);
+    instanceIds.forEach((instance_id) => {
+      get().removeLegHideStates(instance_id);
+      get().removeLegConnectionStates(instance_id);
+      get().removeLegoFromConnectionMap(instance_id);
     });
     // Update all leg hide states to account for the removed legos
     get().updateAllLegHideStates();
@@ -317,31 +319,31 @@ export const createLegoSlice: StateCreator<
     get().updateEncodedCanvasState();
   },
 
-  updateDroppedLego: (instanceId: string, updates: DroppedLego) => {
+  updateDroppedLego: (instance_id: string, updates: DroppedLego) => {
     set((state) => {
       const legoIndex = state.droppedLegos.findIndex(
-        (l) => l.instanceId === instanceId
+        (l) => l.instance_id === instance_id
       );
       if (legoIndex !== -1) {
         state.droppedLegos[legoIndex] = updates;
       }
       const connectedLegoIndex = state.connectedLegos.findIndex(
-        (l) => l.instanceId === instanceId
+        (l) => l.instance_id === instance_id
       );
       if (connectedLegoIndex !== -1) {
         state.connectedLegos[connectedLegoIndex] = updates;
       }
       state.tensorNetwork?.legos.forEach((lego, index) => {
-        if (lego.instanceId === instanceId) {
+        if (lego.instance_id === instance_id) {
           state.tensorNetwork!.legos[index] = updates;
         }
       });
     });
     // Update leg hide states if the number of legs changed
-    const existingStates = get().getLegHideStates(instanceId);
+    const existingStates = get().getLegHideStates(instance_id);
     if (existingStates.length !== updates.numberOfLegs) {
-      get().initializeLegHideStates(instanceId, updates.numberOfLegs);
-      get().initializeLegConnectionStates(instanceId, updates.numberOfLegs);
+      get().initializeLegHideStates(instance_id, updates.numberOfLegs);
+      get().initializeLegConnectionStates(instance_id, updates.numberOfLegs);
     }
     // Update all leg hide states to account for the updated lego
     get().updateAllLegHideStates();
@@ -351,25 +353,25 @@ export const createLegoSlice: StateCreator<
   moveDroppedLegos: (legos: DroppedLego[]) => {
     set((state) => {
       // Create a Map of the updates for quick lookup
-      const updatesMap = new Map(legos.map((lego) => [lego.instanceId, lego]));
+      const updatesMap = new Map(legos.map((lego) => [lego.instance_id, lego]));
 
       // Iterate over the existing legos and replace them if an update exists
       state.droppedLegos.forEach((lego, index) => {
-        const updatedLego = updatesMap.get(lego.instanceId);
+        const updatedLego = updatesMap.get(lego.instance_id);
         if (updatedLego) {
           state.droppedLegos[index] = updatedLego;
         }
       });
 
       state.connectedLegos.forEach((lego, index) => {
-        const updatedLego = updatesMap.get(lego.instanceId);
+        const updatedLego = updatesMap.get(lego.instance_id);
         if (updatedLego) {
           state.connectedLegos[index] = updatedLego;
         }
       });
 
       state.tensorNetwork?.legos.forEach((lego, index) => {
-        const updatedLego = updatesMap.get(lego.instanceId);
+        const updatedLego = updatesMap.get(lego.instance_id);
         if (updatedLego) {
           state.tensorNetwork!.legos[index] = updatedLego;
         }
@@ -380,24 +382,24 @@ export const createLegoSlice: StateCreator<
   updateDroppedLegos: (legos: DroppedLego[]) => {
     set((state) => {
       // Create a Map of the updates for quick lookup
-      const updatesMap = new Map(legos.map((lego) => [lego.instanceId, lego]));
+      const updatesMap = new Map(legos.map((lego) => [lego.instance_id, lego]));
 
       // Iterate over the existing legos and replace them if an update exists
       state.droppedLegos.forEach((lego, index) => {
-        const updatedLego = updatesMap.get(lego.instanceId);
+        const updatedLego = updatesMap.get(lego.instance_id);
         if (updatedLego) {
           state.droppedLegos[index] = updatedLego;
         }
       });
 
       state.connectedLegos.forEach((lego, index) => {
-        const updatedLego = updatesMap.get(lego.instanceId);
+        const updatedLego = updatesMap.get(lego.instance_id);
         if (updatedLego) {
           state.connectedLegos[index] = updatedLego;
         }
       });
       state.tensorNetwork?.legos.forEach((lego, index) => {
-        const updatedLego = updatesMap.get(lego.instanceId);
+        const updatedLego = updatesMap.get(lego.instance_id);
         if (updatedLego) {
           state.tensorNetwork!.legos[index] = updatedLego;
         }
@@ -405,10 +407,13 @@ export const createLegoSlice: StateCreator<
     });
     // Update leg hide states for updated legos
     legos.forEach((lego) => {
-      const existingStates = get().getLegHideStates(lego.instanceId);
+      const existingStates = get().getLegHideStates(lego.instance_id);
       if (existingStates.length !== lego.numberOfLegs) {
-        get().initializeLegHideStates(lego.instanceId, lego.numberOfLegs);
-        get().initializeLegConnectionStates(lego.instanceId, lego.numberOfLegs);
+        get().initializeLegHideStates(lego.instance_id, lego.numberOfLegs);
+        get().initializeLegConnectionStates(
+          lego.instance_id,
+          lego.numberOfLegs
+        );
       }
     });
 
diff --git a/app/ui/src/stores/encodedCanvasStateSlice.ts b/app/ui/src/stores/encodedCanvasStateSlice.ts
index dfd31f74..c9b54c35 100644
--- a/app/ui/src/stores/encodedCanvasStateSlice.ts
+++ b/app/ui/src/stores/encodedCanvasStateSlice.ts
@@ -33,8 +33,8 @@ export const createEncodedCanvasStateSlice: StateCreator<
         connectedLegos: result.pieces.filter((lego) =>
           result.connections.some(
             (connection) =>
-              connection.from.legoId === lego.instanceId ||
-              connection.to.legoId === lego.instanceId
+              connection.from.legoId === lego.instance_id ||
+              connection.to.legoId === lego.instance_id
           )
         ),
         hideConnectedLegs: result.hideConnectedLegs
@@ -42,8 +42,11 @@ export const createEncodedCanvasStateSlice: StateCreator<
 
       // Initialize leg hide states for all legos
       result.pieces.forEach((lego) => {
-        get().initializeLegHideStates(lego.instanceId, lego.numberOfLegs);
-        get().initializeLegConnectionStates(lego.instanceId, lego.numberOfLegs);
+        get().initializeLegHideStates(lego.instance_id, lego.numberOfLegs);
+        get().initializeLegConnectionStates(
+          lego.instance_id,
+          lego.numberOfLegs
+        );
       });
 
       // Update all leg hide states based on the loaded connections
diff --git a/app/ui/src/stores/groupDragState.ts b/app/ui/src/stores/groupDragState.ts
index fc78ed27..edb29b8c 100644
--- a/app/ui/src/stores/groupDragState.ts
+++ b/app/ui/src/stores/groupDragState.ts
@@ -5,7 +5,7 @@ import { LogicalPoint } from "../types/coordinates";
 // Add a new interface for group drag state
 export interface GroupDragState {
   legoInstanceIds: string[];
-  originalPositions: { [instanceId: string]: LogicalPoint };
+  originalPositions: { [instance_id: string]: LogicalPoint };
 }
 export interface GroupDragStateSlice {
   groupDragState: GroupDragState | null;
diff --git a/app/ui/src/stores/legDragState.ts b/app/ui/src/stores/legDragState.ts
index 45aeedf5..10d88010 100644
--- a/app/ui/src/stores/legDragState.ts
+++ b/app/ui/src/stores/legDragState.ts
@@ -5,7 +5,7 @@ import { WindowPoint } from "../types/coordinates";
 export interface LegDragState {
   isDragging: boolean;
   legoId: string;
-  legIndex: number;
+  leg_index: number;
   startMouseWindowPoint: WindowPoint;
   currentMouseWindowPoint: WindowPoint;
 }
diff --git a/app/ui/src/stores/legoLegPropertiesSlice.ts b/app/ui/src/stores/legoLegPropertiesSlice.ts
index 152cf206..eacefe42 100644
--- a/app/ui/src/stores/legoLegPropertiesSlice.ts
+++ b/app/ui/src/stores/legoLegPropertiesSlice.ts
@@ -81,19 +81,19 @@ export const createLegoLegPropertiesSlice: StateCreator<
   // This is extracted from the original shouldHideLeg logic
   const calculateLegHideState = (
     lego: DroppedLego,
-    legIndex: number,
+    leg_index: number,
     connections: Connection[]
   ): boolean => {
     const isConnected = connections.some((connection) => {
       if (
-        connection.from.legoId === lego.instanceId &&
-        connection.from.legIndex === legIndex
+        connection.from.legoId === lego.instance_id &&
+        connection.from.leg_index === leg_index
       ) {
         return true;
       }
       if (
-        connection.to.legoId === lego.instanceId &&
-        connection.to.legIndex === legIndex
+        connection.to.legoId === lego.instance_id &&
+        connection.to.leg_index === leg_index
       ) {
         return true;
       }
@@ -102,7 +102,7 @@ export const createLegoLegPropertiesSlice: StateCreator<
 
     if (!isConnected) return false;
 
-    const thisLegStyle = lego.style!.legStyles[legIndex];
+    const thisLegStyle = lego.style!.legStyles[leg_index];
     const isThisHighlighted = thisLegStyle.is_highlighted;
 
     // If this leg is not highlighted, hide it only if connected to a non-highlighted leg
@@ -110,28 +110,28 @@ export const createLegoLegPropertiesSlice: StateCreator<
       // Check if connected to a highlighted leg
       return !connections.some((conn) => {
         if (
-          conn.from.legoId === lego.instanceId &&
-          conn.from.legIndex === legIndex
+          conn.from.legoId === lego.instance_id &&
+          conn.from.leg_index === leg_index
         ) {
           // Get connected lego from store
           const connectedLego = get().droppedLegos.find(
-            (l) => l.instanceId === conn.to.legoId
+            (l) => l.instance_id === conn.to.legoId
           );
           return (
-            connectedLego?.style!.legStyles[conn.to.legIndex].is_highlighted ||
+            connectedLego?.style!.legStyles[conn.to.leg_index].is_highlighted ||
             false
           );
         }
         if (
-          conn.to.legoId === lego.instanceId &&
-          conn.to.legIndex === legIndex
+          conn.to.legoId === lego.instance_id &&
+          conn.to.leg_index === leg_index
         ) {
           // Get connected lego from store
           const connectedLego = get().droppedLegos.find(
-            (l) => l.instanceId === conn.from.legoId
+            (l) => l.instance_id === conn.from.legoId
           );
           return (
-            connectedLego?.style!.legStyles[conn.from.legIndex]
+            connectedLego?.style!.legStyles[conn.from.leg_index]
               .is_highlighted || false
           );
         }
@@ -142,27 +142,30 @@ export const createLegoLegPropertiesSlice: StateCreator<
     // If this leg is highlighted, hide it only if connected to a leg with the same highlight color
     return connections.some((conn) => {
       if (
-        conn.from.legoId === lego.instanceId &&
-        conn.from.legIndex === legIndex
+        conn.from.legoId === lego.instance_id &&
+        conn.from.leg_index === leg_index
       ) {
         // Get connected lego from store
         const connectedLego = get().droppedLegos.find(
-          (l) => l.instanceId === conn.to.legoId
+          (l) => l.instance_id === conn.to.legoId
         );
         const connectedStyle =
-          connectedLego?.style!.legStyles[conn.to.legIndex];
+          connectedLego?.style!.legStyles[conn.to.leg_index];
         return (
           connectedStyle?.is_highlighted &&
           connectedStyle.color === thisLegStyle.color
         );
       }
-      if (conn.to.legoId === lego.instanceId && conn.to.legIndex === legIndex) {
+      if (
+        conn.to.legoId === lego.instance_id &&
+        conn.to.leg_index === leg_index
+      ) {
         // Get connected lego from store
         const connectedLego = get().droppedLegos.find(
-          (l) => l.instanceId === conn.from.legoId
+          (l) => l.instance_id === conn.from.legoId
         );
         const connectedStyle =
-          connectedLego?.style!.legStyles[conn.from.legIndex];
+          connectedLego?.style!.legStyles[conn.from.leg_index];
         return (
           connectedStyle?.is_highlighted &&
           connectedStyle.color === thisLegStyle.color
@@ -235,16 +238,20 @@ export const createLegoLegPropertiesSlice: StateCreator<
 
           // Only calculate hide states if the feature is enabled and lego doesn't always show legs
           if (hideConnectedLegs && !lego.alwaysShowLegs) {
-            for (let legIndex = 0; legIndex < lego.numberOfLegs; legIndex++) {
-              hideStates[legIndex] = calculateLegHideState(
+            for (
+              let leg_index = 0;
+              leg_index < lego.numberOfLegs;
+              leg_index++
+            ) {
+              hideStates[leg_index] = calculateLegHideState(
                 lego,
-                legIndex,
+                leg_index,
                 connections
               );
             }
           }
 
-          state.legHideStates[lego.instanceId] = hideStates;
+          state.legHideStates[lego.instance_id] = hideStates;
         });
       });
 
@@ -270,17 +277,21 @@ export const createLegoLegPropertiesSlice: StateCreator<
 
           // Only calculate connection states if the feature is enabled and lego doesn't always show legs
           if (!lego.alwaysShowLegs) {
-            for (let legIndex = 0; legIndex < lego.numberOfLegs; legIndex++) {
-              connectionStates[legIndex] = connections.some((conn) => {
+            for (
+              let leg_index = 0;
+              leg_index < lego.numberOfLegs;
+              leg_index++
+            ) {
+              connectionStates[leg_index] = connections.some((conn) => {
                 if (
-                  conn.from.legoId === lego.instanceId &&
-                  conn.from.legIndex === legIndex
+                  conn.from.legoId === lego.instance_id &&
+                  conn.from.leg_index === leg_index
                 ) {
                   return true;
                 }
                 if (
-                  conn.to.legoId === lego.instanceId &&
-                  conn.to.legIndex === legIndex
+                  conn.to.legoId === lego.instance_id &&
+                  conn.to.leg_index === leg_index
                 ) {
                   return true;
                 }
@@ -289,7 +300,7 @@ export const createLegoLegPropertiesSlice: StateCreator<
             }
           }
 
-          state.legConnectionStates[lego.instanceId] = connectionStates;
+          state.legConnectionStates[lego.instance_id] = connectionStates;
         });
       });
     },
@@ -308,31 +319,31 @@ export const createLegoLegPropertiesSlice: StateCreator<
         // Calculate highlight states for each connection
         connections.forEach((conn) => {
           const fromLego = droppedLegos.find(
-            (l) => l.instanceId === conn.from.legoId
+            (l) => l.instance_id === conn.from.legoId
           );
           const toLego = droppedLegos.find(
-            (l) => l.instanceId === conn.to.legoId
+            (l) => l.instance_id === conn.to.legoId
           );
 
           if (!fromLego || !toLego) return;
 
-          const fromLegStyle = fromLego.style!.legStyles[conn.from.legIndex];
-          const toLegStyle = toLego.style!.legStyles[conn.to.legIndex];
+          const fromLegStyle = fromLego.style!.legStyles[conn.from.leg_index];
+          const toLegStyle = toLego.style!.legStyles[conn.to.leg_index];
 
           // Create a stable connection key
           const [firstId, firstLeg, secondId, secondLeg] =
             conn.from.legoId < conn.to.legoId
               ? [
                   conn.from.legoId,
-                  conn.from.legIndex,
+                  conn.from.leg_index,
                   conn.to.legoId,
-                  conn.to.legIndex
+                  conn.to.leg_index
                 ]
               : [
                   conn.to.legoId,
-                  conn.to.legIndex,
+                  conn.to.leg_index,
                   conn.from.legoId,
-                  conn.from.legIndex
+                  conn.from.leg_index
                 ];
           const connectionKey = `${firstId}-${firstLeg}-${secondId}-${secondLeg}`;
 
@@ -358,17 +369,17 @@ export const createLegoLegPropertiesSlice: StateCreator<
         for (const lego of droppedLegos) {
           const newConnections = connections.filter(
             (conn) =>
-              conn.from.legoId === lego.instanceId ||
-              conn.to.legoId === lego.instanceId
+              conn.from.legoId === lego.instance_id ||
+              conn.to.legoId === lego.instance_id
           );
-          const prevConnections = state.legoConnectionMap[lego.instanceId];
+          const prevConnections = state.legoConnectionMap[lego.instance_id];
           // Only replace if changed (shallow compare)
           if (
             !prevConnections ||
             prevConnections.length !== newConnections.length ||
             prevConnections.some((c, i) => c !== newConnections[i])
           ) {
-            state.legoConnectionMap[lego.instanceId] = newConnections;
+            state.legoConnectionMap[lego.instance_id] = newConnections;
           }
           // else: keep the same array reference!
         }
diff --git a/app/ui/src/transformations/AddStopper.ts b/app/ui/src/transformations/AddStopper.ts
index c7706b0e..b9bfcdd1 100644
--- a/app/ui/src/transformations/AddStopper.ts
+++ b/app/ui/src/transformations/AddStopper.ts
@@ -22,10 +22,10 @@ export class AddStopper {
     // Verify the leg is not already connected
     const isLegConnected = this.connections.some(
       (conn) =>
-        (conn.from.legoId === targetLego.instanceId &&
-          conn.from.legIndex === targetLegIndex) ||
-        (conn.to.legoId === targetLego.instanceId &&
-          conn.to.legIndex === targetLegIndex)
+        (conn.from.legoId === targetLego.instance_id &&
+          conn.from.leg_index === targetLegIndex) ||
+        (conn.to.legoId === targetLego.instance_id &&
+          conn.to.leg_index === targetLegIndex)
     );
 
     if (isLegConnected) {
@@ -34,7 +34,7 @@ export class AddStopper {
 
     // Check if the stopper lego already exists in droppedLegos
     const existingStopperIndex = this.droppedLegos.findIndex(
-      (l) => l.instanceId === stopperLego.instanceId
+      (l) => l.instance_id === stopperLego.instance_id
     );
     let updatedLegos: DroppedLego[];
 
@@ -51,12 +51,12 @@ export class AddStopper {
     // Create new connection to the stopper
     const newConnection = new Connection(
       {
-        legoId: targetLego.instanceId,
-        legIndex: targetLegIndex
+        legoId: targetLego.instance_id,
+        leg_index: targetLegIndex
       },
       {
-        legoId: stopperLego.instanceId,
-        legIndex: 0
+        legoId: stopperLego.instance_id,
+        leg_index: 0
       }
     );
 
diff --git a/app/ui/src/transformations/AutoPauliFlow.test.ts b/app/ui/src/transformations/AutoPauliFlow.test.ts
index d0efc2ed..22c2c83c 100644
--- a/app/ui/src/transformations/AutoPauliFlow.test.ts
+++ b/app/ui/src/transformations/AutoPauliFlow.test.ts
@@ -23,7 +23,7 @@ describe("simple auto flow", () => {
       {
         type_id: id,
         name: name,
-        shortName: name,
+        short_name: name,
         description: name,
         parity_check_matrix: parityMatrix,
         logical_legs: [],
@@ -41,8 +41,8 @@ describe("simple auto flow", () => {
     toIdx: number
   ) =>
     new Connection(
-      { legoId: fromId, legIndex: fromIdx },
-      { legoId: toId, legIndex: toIdx }
+      { legoId: fromId, leg_index: fromIdx },
+      { legoId: toId, leg_index: toIdx }
     );
 
   // Helper function to test simpleAutoFlow
@@ -99,12 +99,12 @@ describe("simple auto flow", () => {
     );
 
     const updatedX = updatedLegos.find(
-      (lego: DroppedLego) => lego.instanceId === "lego1"
+      (lego: DroppedLego) => lego.instance_id === "lego1"
     );
     expect(updatedX!.selectedMatrixRows).toHaveLength(0);
 
     const updatedT5 = updatedLegos.find(
-      (lego: DroppedLego) => lego.instanceId === "lego2"
+      (lego: DroppedLego) => lego.instance_id === "lego2"
     );
     expect(updatedT5!.selectedMatrixRows).toHaveLength(0);
   });
@@ -140,13 +140,13 @@ describe("simple auto flow", () => {
     );
 
     const updatedX = updatedLegos.find(
-      (lego: DroppedLego) => lego.instanceId === "lego1"
+      (lego: DroppedLego) => lego.instance_id === "lego1"
     );
     expect(updatedX!.selectedMatrixRows).toEqual(expect.arrayContaining([0]));
     expect(updatedX!.selectedMatrixRows).toHaveLength(1);
 
     const updatedT5 = updatedLegos.find(
-      (lego: DroppedLego) => lego.instanceId === "lego2"
+      (lego: DroppedLego) => lego.instance_id === "lego2"
     );
     expect(updatedT5!.selectedMatrixRows).toEqual(expect.arrayContaining([0]));
     expect(updatedT5!.selectedMatrixRows).toHaveLength(1);
@@ -186,13 +186,13 @@ describe("simple auto flow", () => {
     );
 
     const updatedX = firstResult.find(
-      (lego: DroppedLego) => lego.instanceId === "lego1"
+      (lego: DroppedLego) => lego.instance_id === "lego1"
     );
     expect(updatedX!.selectedMatrixRows).toEqual(expect.arrayContaining([1]));
     expect(updatedX!.selectedMatrixRows).toHaveLength(1);
 
     const updatedT5 = firstResult.find(
-      (lego: DroppedLego) => lego.instanceId === "lego2"
+      (lego: DroppedLego) => lego.instance_id === "lego2"
     );
     expect(updatedT5!.selectedMatrixRows).toEqual(expect.arrayContaining([0]));
     expect(updatedT5!.selectedMatrixRows).toHaveLength(1);
@@ -207,13 +207,13 @@ describe("simple auto flow", () => {
     );
 
     const updatedX2 = secondResult.find(
-      (lego: DroppedLego) => lego.instanceId === "lego1"
+      (lego: DroppedLego) => lego.instance_id === "lego1"
     );
     expect(updatedX2!.selectedMatrixRows).toEqual(expect.arrayContaining([0]));
     expect(updatedX2!.selectedMatrixRows).toHaveLength(1);
 
     const updatedT52 = secondResult.find(
-      (lego: DroppedLego) => lego.instanceId === "lego2"
+      (lego: DroppedLego) => lego.instance_id === "lego2"
     );
     expect(updatedT52!.selectedMatrixRows).toEqual(expect.arrayContaining([1]));
     expect(updatedT52!.selectedMatrixRows).toHaveLength(1);
@@ -250,13 +250,13 @@ describe("simple auto flow", () => {
     );
 
     const updatedX = updatedLegos.find(
-      (lego: DroppedLego) => lego.instanceId === "lego1"
+      (lego: DroppedLego) => lego.instance_id === "lego1"
     );
     expect(updatedX!.selectedMatrixRows).toEqual(expect.arrayContaining([0]));
     expect(updatedX!.selectedMatrixRows).toHaveLength(1);
 
     const updatedT5 = updatedLegos.find(
-      (lego: DroppedLego) => lego.instanceId === "lego2"
+      (lego: DroppedLego) => lego.instance_id === "lego2"
     );
     expect(updatedT5!.selectedMatrixRows).toHaveLength(0);
   });
@@ -292,12 +292,12 @@ describe("simple auto flow", () => {
     );
 
     const updatedX = updatedLegos.find(
-      (lego: DroppedLego) => lego.instanceId === "lego1"
+      (lego: DroppedLego) => lego.instance_id === "lego1"
     );
     expect(updatedX!.selectedMatrixRows).toHaveLength(0);
 
     const updatedT5 = updatedLegos.find(
-      (lego: DroppedLego) => lego.instanceId === "lego2"
+      (lego: DroppedLego) => lego.instance_id === "lego2"
     );
     expect(updatedT5!.selectedMatrixRows).toEqual(expect.arrayContaining([1]));
     expect(updatedT5!.selectedMatrixRows).toHaveLength(1);
@@ -353,24 +353,24 @@ describe("simple auto flow", () => {
     );
 
     const updatedX = updatedLegos.find(
-      (lego: DroppedLego) => lego.instanceId === "lego1"
+      (lego: DroppedLego) => lego.instance_id === "lego1"
     );
     expect(updatedX!.selectedMatrixRows).toHaveLength(1);
 
     const updatedT5 = updatedLegos.find(
-      (lego: DroppedLego) => lego.instanceId === "lego2"
+      (lego: DroppedLego) => lego.instance_id === "lego2"
     );
     expect(updatedT5!.selectedMatrixRows).toEqual(expect.arrayContaining([0]));
     expect(updatedT5!.selectedMatrixRows).toHaveLength(1);
 
     const updatedH = updatedLegos.find(
-      (lego: DroppedLego) => lego.instanceId === "lego3"
+      (lego: DroppedLego) => lego.instance_id === "lego3"
     );
     expect(updatedH!.selectedMatrixRows).toEqual(expect.arrayContaining([1]));
     expect(updatedH!.selectedMatrixRows).toHaveLength(1);
 
     const updatedZ = updatedLegos.find(
-      (lego: DroppedLego) => lego.instanceId === "lego4"
+      (lego: DroppedLego) => lego.instance_id === "lego4"
     );
     expect(updatedZ!.selectedMatrixRows).toHaveLength(1);
   });
@@ -425,24 +425,24 @@ describe("simple auto flow", () => {
     );
 
     const updatedX = updatedLegos.find(
-      (lego: DroppedLego) => lego.instanceId === "lego1"
+      (lego: DroppedLego) => lego.instance_id === "lego1"
     );
     expect(updatedX!.selectedMatrixRows).toHaveLength(0);
 
     const updatedT5 = updatedLegos.find(
-      (lego: DroppedLego) => lego.instanceId === "lego2"
+      (lego: DroppedLego) => lego.instance_id === "lego2"
     );
     expect(updatedT5!.selectedMatrixRows).toEqual(expect.arrayContaining([1]));
     expect(updatedT5!.selectedMatrixRows).toHaveLength(1);
 
     const updatedH = updatedLegos.find(
-      (lego: DroppedLego) => lego.instanceId === "lego3"
+      (lego: DroppedLego) => lego.instance_id === "lego3"
     );
     expect(updatedH!.selectedMatrixRows).toEqual(expect.arrayContaining([0]));
     expect(updatedH!.selectedMatrixRows).toHaveLength(1);
 
     const updatedZ = updatedLegos.find(
-      (lego: DroppedLego) => lego.instanceId === "lego4"
+      (lego: DroppedLego) => lego.instance_id === "lego4"
     );
     expect(updatedZ!.selectedMatrixRows).toHaveLength(0);
   });
@@ -520,28 +520,28 @@ describe("simple auto flow", () => {
     );
 
     const updatedX = updatedLegos.find(
-      (lego: DroppedLego) => lego.instanceId === "lego1"
+      (lego: DroppedLego) => lego.instance_id === "lego1"
     );
     expect(updatedX!.selectedMatrixRows).toHaveLength(0);
 
     const updatedT5 = updatedLegos.find(
-      (lego: DroppedLego) => lego.instanceId === "lego2"
+      (lego: DroppedLego) => lego.instance_id === "lego2"
     );
     expect(updatedT5!.selectedMatrixRows).toEqual(expect.arrayContaining([1]));
     expect(updatedT5!.selectedMatrixRows).toHaveLength(1);
 
     const updatedH = updatedLegos.find(
-      (lego: DroppedLego) => lego.instanceId === "lego3"
+      (lego: DroppedLego) => lego.instance_id === "lego3"
     );
     expect(updatedH!.selectedMatrixRows).toHaveLength(0);
 
     const updatedZ = updatedLegos.find(
-      (lego: DroppedLego) => lego.instanceId === "lego4"
+      (lego: DroppedLego) => lego.instance_id === "lego4"
     );
     expect(updatedZ!.selectedMatrixRows).toHaveLength(0);
 
     const updatedT52 = updatedLegos.find(
-      (lego: DroppedLego) => lego.instanceId === "lego5"
+      (lego: DroppedLego) => lego.instance_id === "lego5"
     );
     expect(updatedT52!.selectedMatrixRows).toHaveLength(0);
   });
@@ -594,19 +594,19 @@ describe("simple auto flow", () => {
     );
 
     const updatedT51 = updatedLegos.find(
-      (lego: DroppedLego) => lego.instanceId === "lego1"
+      (lego: DroppedLego) => lego.instance_id === "lego1"
     );
     expect(updatedT51!.selectedMatrixRows).toEqual(expect.arrayContaining([1]));
     expect(updatedT51!.selectedMatrixRows).toHaveLength(1);
 
     const updatedT52 = updatedLegos.find(
-      (lego: DroppedLego) => lego.instanceId === "lego2"
+      (lego: DroppedLego) => lego.instance_id === "lego2"
     );
     expect(updatedT52!.selectedMatrixRows).toEqual(expect.arrayContaining([1]));
     expect(updatedT52!.selectedMatrixRows).toHaveLength(1);
 
     const updatedH = updatedLegos.find(
-      (lego: DroppedLego) => lego.instanceId === "lego3"
+      (lego: DroppedLego) => lego.instance_id === "lego3"
     );
     expect(updatedH!.selectedMatrixRows).toEqual(expect.arrayContaining([1]));
     expect(updatedH!.selectedMatrixRows).toHaveLength(1);
@@ -660,19 +660,19 @@ describe("simple auto flow", () => {
     );
 
     const updatedT51 = updatedLegos.find(
-      (lego: DroppedLego) => lego.instanceId === "lego1"
+      (lego: DroppedLego) => lego.instance_id === "lego1"
     );
     expect(updatedT51!.selectedMatrixRows).toEqual(expect.arrayContaining([1]));
     expect(updatedT51!.selectedMatrixRows).toHaveLength(1);
 
     const updatedT52 = updatedLegos.find(
-      (lego: DroppedLego) => lego.instanceId === "lego2"
+      (lego: DroppedLego) => lego.instance_id === "lego2"
     );
     expect(updatedT52!.selectedMatrixRows).toEqual(expect.arrayContaining([2]));
     expect(updatedT52!.selectedMatrixRows).toHaveLength(1);
 
     const updatedH = updatedLegos.find(
-      (lego: DroppedLego) => lego.instanceId === "lego3"
+      (lego: DroppedLego) => lego.instance_id === "lego3"
     );
     expect(updatedH!.selectedMatrixRows).toEqual(expect.arrayContaining([0]));
     expect(updatedH!.selectedMatrixRows).toHaveLength(1);
@@ -725,7 +725,7 @@ describe("simple auto flow", () => {
     );
 
     const updatedT5 = updatedLegos.find(
-      (lego: DroppedLego) => lego.instanceId === "lego1"
+      (lego: DroppedLego) => lego.instance_id === "lego1"
     );
     expect(updatedT5!.selectedMatrixRows).toEqual(
       expect.arrayContaining([0, 1])
@@ -733,7 +733,7 @@ describe("simple auto flow", () => {
     expect(updatedT5!.selectedMatrixRows).toHaveLength(2);
 
     const updatedH1 = updatedLegos.find(
-      (lego: DroppedLego) => lego.instanceId === "lego2"
+      (lego: DroppedLego) => lego.instance_id === "lego2"
     );
     expect(updatedH1!.selectedMatrixRows).toEqual(
       expect.arrayContaining([0, 1])
@@ -741,7 +741,7 @@ describe("simple auto flow", () => {
     expect(updatedH1!.selectedMatrixRows).toHaveLength(2);
 
     const updatedH2 = updatedLegos.find(
-      (lego: DroppedLego) => lego.instanceId === "lego3"
+      (lego: DroppedLego) => lego.instance_id === "lego3"
     );
     expect(updatedH2!.selectedMatrixRows).toEqual(
       expect.arrayContaining([0, 1])
diff --git a/app/ui/src/transformations/AutoPauliFlow.ts b/app/ui/src/transformations/AutoPauliFlow.ts
index 9f278d0f..4701d6a8 100644
--- a/app/ui/src/transformations/AutoPauliFlow.ts
+++ b/app/ui/src/transformations/AutoPauliFlow.ts
@@ -40,13 +40,13 @@ export function simpleAutoFlow(
     count++;
 
     for (const lego of tnLegos) {
-      if (lego.instanceId === changedLego?.instanceId) {
+      if (lego.instance_id === changedLego?.instance_id) {
         continue;
       }
       const neighborConns = connections.filter(
         (conn) =>
-          conn.from.legoId === lego.instanceId ||
-          conn.to.legoId === lego.instanceId
+          conn.from.legoId === lego.instance_id ||
+          conn.to.legoId === lego.instance_id
       );
 
       if (neighborConns.length === 0) {
@@ -55,23 +55,23 @@ export function simpleAutoFlow(
       for (const neighborConn of neighborConns) {
         const neighborLego = tnLegos.find(
           (l: DroppedLego) =>
-            (l.instanceId === neighborConn.from.legoId ||
-              l.instanceId === neighborConn.to.legoId) &&
-            l.instanceId != lego.instanceId
+            (l.instance_id === neighborConn.from.legoId ||
+              l.instance_id === neighborConn.to.legoId) &&
+            l.instance_id != lego.instance_id
         );
         if (!neighborLego) {
           continue;
         }
 
         const neighborLegIndex =
-          neighborConn.from.legoId == neighborLego.instanceId
-            ? neighborConn.from.legIndex
-            : neighborConn.to.legIndex;
+          neighborConn.from.legoId == neighborLego.instance_id
+            ? neighborConn.from.leg_index
+            : neighborConn.to.leg_index;
 
         const legoLegIndex =
-          neighborConn.from.legoId == lego.instanceId
-            ? neighborConn.from.legIndex
-            : neighborConn.to.legIndex;
+          neighborConn.from.legoId == lego.instance_id
+            ? neighborConn.from.leg_index
+            : neighborConn.to.leg_index;
 
         const legoLegHighlightOp = getHighlightOp(lego, legoLegIndex);
         const neighborLegHighlightOp = getHighlightOp(
@@ -85,7 +85,7 @@ export function simpleAutoFlow(
           neighborLegHighlightOp[0] === legoLegHighlightOp[0] &&
           neighborLegHighlightOp[1] === legoLegHighlightOp[1]
         ) {
-          seenLegos.add(lego.instanceId);
+          seenLegos.add(lego.instance_id);
           continue;
         }
         if (!isSimpleLego(lego)) {
@@ -124,17 +124,17 @@ export function simpleAutoFlow(
         if (newRows !== null) {
           // ensure the lego has not been changed already
           if (
-            !seenLegos.has(lego.instanceId) ||
+            !seenLegos.has(lego.instance_id) ||
             // lego can only be changed again if highlighting an unhighlighted lego
             (newRows?.length > 0 && lego.selectedMatrixRows.length === 0) ||
             // or can be changed again if neighbor of changedLego --> it has priority
             (lego.selectedMatrixRows.length > 0 &&
-              neighborLego.instanceId === changedLego?.instanceId &&
+              neighborLego.instance_id === changedLego?.instance_id &&
               newRows?.length > 0)
           ) {
-            tnLegos = updateLego(tnLegos, lego.instanceId, newRows);
-            updatedLegosMap.set(lego.instanceId, newRows);
-            seenLegos.add(lego.instanceId);
+            tnLegos = updateLego(tnLegos, lego.instance_id, newRows);
+            updatedLegosMap.set(lego.instance_id, newRows);
+            seenLegos.add(lego.instance_id);
             changed = true;
             updateNeeded = true;
           }
@@ -147,8 +147,8 @@ export function simpleAutoFlow(
     // Apply all changes at once to make sure all updates are done
     setDroppedLegos(
       droppedLegos.map((l) =>
-        updatedLegosMap.has(l.instanceId)
-          ? l.with({ selectedMatrixRows: updatedLegosMap.get(l.instanceId)! })
+        updatedLegosMap.has(l.instance_id)
+          ? l.with({ selectedMatrixRows: updatedLegosMap.get(l.instance_id)! })
           : l
       )
     );
@@ -169,7 +169,7 @@ const updateLego = (
   newRows: number[]
 ): DroppedLego[] => {
   const updatedLegos = tnLegos.map((l) =>
-    l.instanceId === targetId ? l.with({ selectedMatrixRows: newRows }) : l
+    l.instance_id === targetId ? l.with({ selectedMatrixRows: newRows }) : l
   );
   return updatedLegos;
 };
@@ -177,10 +177,10 @@ const updateLego = (
 /**
  * Helper method to find the current highlight operation of the given lego at leg index.
  * @param lego
- * @param legIndex
+ * @param leg_index
  * @returns X and Z parts of the highlight operation
  */
-const getHighlightOp = (lego: DroppedLego, legIndex: number) => {
+const getHighlightOp = (lego: DroppedLego, leg_index: number) => {
   const nLegoLegs = lego.numberOfLegs;
   const combinedRow = new Array(lego.parity_check_matrix[0].length).fill(0);
 
@@ -189,28 +189,28 @@ const getHighlightOp = (lego: DroppedLego, legIndex: number) => {
       combinedRow[idx] = (combinedRow[idx] + val) % 2;
     });
   }
-  const xPart = combinedRow[legIndex];
-  const zPart = combinedRow[legIndex + nLegoLegs];
+  const xPart = combinedRow[leg_index];
+  const zPart = combinedRow[leg_index + nLegoLegs];
   return [xPart, zPart];
 };
 
 /**
  * Helper method to find the X and Z rows in the parity check matrix that correspond to the given leg index.
  * @param lego
- * @param legIndex
+ * @param leg_index
  * @returns List of X and Z row indices
  */
 const findRowIndices = (
   lego: DroppedLego,
-  legIndex: number
+  leg_index: number
 ): { xRowIndices: number[]; zRowIndices: number[] } => {
   const nLegoLegs = lego.numberOfLegs;
   const xRowIndices: number[] = [];
   const zRowIndices: number[] = [];
 
   lego.parity_check_matrix.forEach((row, idx) => {
-    if (row[legIndex] === 1) xRowIndices.push(idx);
-    if (row[legIndex + nLegoLegs] === 1) zRowIndices.push(idx);
+    if (row[leg_index] === 1) xRowIndices.push(idx);
+    if (row[leg_index + nLegoLegs] === 1) zRowIndices.push(idx);
   });
 
   return { xRowIndices, zRowIndices };
diff --git a/app/ui/src/transformations/Bialgebra.ts b/app/ui/src/transformations/Bialgebra.ts
index 9bf97356..65a7c848 100644
--- a/app/ui/src/transformations/Bialgebra.ts
+++ b/app/ui/src/transformations/Bialgebra.ts
@@ -21,7 +21,8 @@ export function canDoBialgebra(
   // Count connections between the two selected legos
   const connectionsBetween = connections.filter(
     (conn) =>
-      conn.containsLego(lego1.instanceId) && conn.containsLego(lego2.instanceId)
+      conn.containsLego(lego1.instance_id) &&
+      conn.containsLego(lego2.instance_id)
   );
   // There should be exactly one connection between them
   return connectionsBetween.length === 1;
@@ -39,17 +40,18 @@ export async function applyBialgebra(
   const [lego1, lego2] = legosToCommute;
   const connectionsBetween = connections.filter(
     (conn) =>
-      conn.containsLego(lego1.instanceId) && conn.containsLego(lego2.instanceId)
+      conn.containsLego(lego1.instance_id) &&
+      conn.containsLego(lego2.instance_id)
   );
   const connectionsToLego1 = connections.filter(
     (conn) =>
-      conn.containsLego(lego1.instanceId) &&
-      !conn.containsLego(lego2.instanceId)
+      conn.containsLego(lego1.instance_id) &&
+      !conn.containsLego(lego2.instance_id)
   );
   const connectionsToLego2 = connections.filter(
     (conn) =>
-      conn.containsLego(lego2.instanceId) &&
-      !conn.containsLego(lego1.instanceId)
+      conn.containsLego(lego2.instance_id) &&
+      !conn.containsLego(lego1.instance_id)
   );
 
   const n_legs_lego1 = lego1.numberOfLegs;
@@ -77,7 +79,7 @@ export async function applyBialgebra(
 
   // Get the maximum instance ID from existing legos
   const maxInstanceId = Math.max(
-    ...droppedLegos.map((l) => parseInt(l.instanceId))
+    ...droppedLegos.map((l) => parseInt(l.instance_id))
   );
 
   // Create first group of legos
@@ -114,12 +116,12 @@ export async function applyBialgebra(
       newConnections.push(
         new Connection(
           {
-            legoId: newLegos[i].instanceId,
-            legIndex: j
+            legoId: newLegos[i].instance_id,
+            leg_index: j
           },
           {
-            legoId: newLegos[n_group_1 + j].instanceId,
-            legIndex: i
+            legoId: newLegos[n_group_1 + j].instance_id,
+            leg_index: i
           }
         )
       );
@@ -129,20 +131,22 @@ export async function applyBialgebra(
   // Create connections for external legs
   connectionsToLego1.forEach((conn, index) => {
     const externalLegoId =
-      conn.from.legoId === lego1.instanceId ? conn.to.legoId : conn.from.legoId;
+      conn.from.legoId === lego1.instance_id
+        ? conn.to.legoId
+        : conn.from.legoId;
     const externalLegIndex =
-      conn.from.legoId === lego1.instanceId
-        ? conn.to.legIndex
-        : conn.from.legIndex;
+      conn.from.legoId === lego1.instance_id
+        ? conn.to.leg_index
+        : conn.from.leg_index;
 
     // Connect only one lego from the first group to each external lego
     newConnections.push(
       new Connection(
         {
-          legoId: newLegos[index].instanceId,
-          legIndex: n_group_2 // Always use the last leg index for external connections
+          legoId: newLegos[index].instance_id,
+          leg_index: n_group_2 // Always use the last leg index for external connections
         },
-        { legoId: externalLegoId, legIndex: externalLegIndex }
+        { legoId: externalLegoId, leg_index: externalLegIndex }
       )
     );
   });
@@ -150,20 +154,22 @@ export async function applyBialgebra(
   // Create external connections for the second group
   connectionsToLego2.forEach((conn, index) => {
     const externalLegoId =
-      conn.from.legoId === lego2.instanceId ? conn.to.legoId : conn.from.legoId;
+      conn.from.legoId === lego2.instance_id
+        ? conn.to.legoId
+        : conn.from.legoId;
     const externalLegIndex =
-      conn.from.legoId === lego2.instanceId
-        ? conn.to.legIndex
-        : conn.from.legIndex;
+      conn.from.legoId === lego2.instance_id
+        ? conn.to.leg_index
+        : conn.from.leg_index;
 
     // Connect only one lego from the second group to each external lego
     newConnections.push(
       new Connection(
         {
-          legoId: newLegos[n_group_1 + index].instanceId,
-          legIndex: n_group_1 // Always use the last leg index for external connections
+          legoId: newLegos[n_group_1 + index].instance_id,
+          leg_index: n_group_1 // Always use the last leg index for external connections
         },
-        { legoId: externalLegoId, legIndex: externalLegIndex }
+        { legoId: externalLegoId, leg_index: externalLegIndex }
       )
     );
   });
@@ -171,7 +177,7 @@ export async function applyBialgebra(
   // Remove old legos and connections
   const updatedDroppedLegos = droppedLegos
     .filter(
-      (lego) => !legosToCommute.some((l) => l.instanceId === lego.instanceId)
+      (lego) => !legosToCommute.some((l) => l.instance_id === lego.instance_id)
     )
     .concat(newLegos);
 
@@ -181,23 +187,23 @@ export async function applyBialgebra(
         !connectionsBetween.some(
           (c) =>
             c.from.legoId === conn.from.legoId &&
-            c.from.legIndex === conn.from.legIndex &&
+            c.from.leg_index === conn.from.leg_index &&
             c.to.legoId === conn.to.legoId &&
-            c.to.legIndex === conn.to.legIndex
+            c.to.leg_index === conn.to.leg_index
         ) &&
         !connectionsToLego1.some(
           (c) =>
             c.from.legoId === conn.from.legoId &&
-            c.from.legIndex === conn.from.legIndex &&
+            c.from.leg_index === conn.from.leg_index &&
             c.to.legoId === conn.to.legoId &&
-            c.to.legIndex === conn.to.legIndex
+            c.to.leg_index === conn.to.leg_index
         ) &&
         !connectionsToLego2.some(
           (c) =>
             c.from.legoId === conn.from.legoId &&
-            c.from.legIndex === conn.from.legIndex &&
+            c.from.leg_index === conn.from.leg_index &&
             c.to.legoId === conn.to.legoId &&
-            c.to.legIndex === conn.to.legIndex
+            c.to.leg_index === conn.to.leg_index
         )
     )
     .concat(newConnections);
diff --git a/app/ui/src/transformations/CompleteGraphViaHadamards.ts b/app/ui/src/transformations/CompleteGraphViaHadamards.ts
index 335b9bfa..a88660be 100644
--- a/app/ui/src/transformations/CompleteGraphViaHadamards.ts
+++ b/app/ui/src/transformations/CompleteGraphViaHadamards.ts
@@ -23,11 +23,11 @@ const getDanglingLegs = (
 
     // Find all connected legs
     connections.forEach((conn) => {
-      if (conn.from.legoId === lego.instanceId) {
-        connectedLegs.add(conn.from.legIndex);
+      if (conn.from.legoId === lego.instance_id) {
+        connectedLegs.add(conn.from.leg_index);
       }
-      if (conn.to.legoId === lego.instanceId) {
-        connectedLegs.add(conn.to.legIndex);
+      if (conn.to.legoId === lego.instance_id) {
+        connectedLegs.add(conn.to.leg_index);
       }
     });
 
@@ -56,7 +56,7 @@ export const applyCompleteGraphViaHadamards = async (
 }> => {
   // Get max instance ID
   const maxInstanceId = Math.max(
-    ...allLegos.map((l) => parseInt(l.instanceId))
+    ...allLegos.map((l) => parseInt(l.instance_id))
   );
 
   // Find dangling legs for each lego
@@ -73,7 +73,7 @@ export const applyCompleteGraphViaHadamards = async (
       return Legos.createDynamicLego(
         "z_rep_code",
         lego.numberOfLegs + numNewLegs,
-        lego.instanceId,
+        lego.instance_id,
         lego.logicalPosition
       );
     }
@@ -88,7 +88,7 @@ export const applyCompleteGraphViaHadamards = async (
 
   // Track which dangling legs have been used for each lego
   const usedDanglingLegs: Map<string, Set<number>> = new Map();
-  legos.forEach((lego) => usedDanglingLegs.set(lego.instanceId, new Set()));
+  legos.forEach((lego) => usedDanglingLegs.set(lego.instance_id, new Set()));
 
   // Create connections between all pairs of legos
   for (let i = 0; i < legos.length; i++) {
@@ -112,7 +112,7 @@ export const applyCompleteGraphViaHadamards = async (
 
       // Find next unused dangling leg for lego1
       let legIndex1: number;
-      const usedLegs1 = usedDanglingLegs.get(lego1.instanceId)!;
+      const usedLegs1 = usedDanglingLegs.get(lego1.instance_id)!;
       const availableDanglingLeg1 = lego1DanglingLegs.find(
         (leg) => !usedLegs1.has(leg)
       );
@@ -128,7 +128,7 @@ export const applyCompleteGraphViaHadamards = async (
 
       // Find next unused dangling leg for lego2
       let legIndex2: number;
-      const usedLegs2 = usedDanglingLegs.get(lego2.instanceId)!;
+      const usedLegs2 = usedDanglingLegs.get(lego2.instance_id)!;
       const availableDanglingLeg2 = lego2DanglingLegs.find(
         (leg) => !usedLegs2.has(leg)
       );
@@ -144,12 +144,12 @@ export const applyCompleteGraphViaHadamards = async (
       // Create connections
       newConnections.push(
         new Connection(
-          { legoId: lego1.instanceId, legIndex: legIndex1 },
-          { legoId: hadamardLego.instanceId, legIndex: 0 }
+          { legoId: lego1.instance_id, leg_index: legIndex1 },
+          { legoId: hadamardLego.instance_id, leg_index: 0 }
         ),
         new Connection(
-          { legoId: hadamardLego.instanceId, legIndex: 1 },
-          { legoId: lego2.instanceId, legIndex: legIndex2 }
+          { legoId: hadamardLego.instance_id, leg_index: 1 },
+          { legoId: lego2.instance_id, leg_index: legIndex2 }
         )
       );
 
@@ -160,7 +160,7 @@ export const applyCompleteGraphViaHadamards = async (
   // Update state
   const updatedLegos = [
     ...allLegos.filter(
-      (l) => !legos.some((selected) => selected.instanceId === l.instanceId)
+      (l) => !legos.some((selected) => selected.instance_id === l.instance_id)
     ),
     ...newLegos,
     ...hadamardLegos
diff --git a/app/ui/src/transformations/ConnectGraphNodesWithCenterLego.ts b/app/ui/src/transformations/ConnectGraphNodesWithCenterLego.ts
index c868b686..7cf98c1a 100644
--- a/app/ui/src/transformations/ConnectGraphNodesWithCenterLego.ts
+++ b/app/ui/src/transformations/ConnectGraphNodesWithCenterLego.ts
@@ -22,7 +22,7 @@ export const applyConnectGraphNodes = async (
 }> => {
   // Get max instance ID
   const maxInstanceId = Math.max(
-    ...allLegos.map((l) => parseInt(l.instanceId))
+    ...allLegos.map((l) => parseInt(l.instance_id))
   );
   const numLegs = legos.length + 1;
 
@@ -44,11 +44,11 @@ export const applyConnectGraphNodes = async (
 
     // Find all connected legs
     connections.forEach((conn) => {
-      if (conn.from.legoId === lego.instanceId) {
-        connectedLegs.add(conn.from.legIndex);
+      if (conn.from.legoId === lego.instance_id) {
+        connectedLegs.add(conn.from.leg_index);
       }
-      if (conn.to.legoId === lego.instanceId) {
-        connectedLegs.add(conn.to.legIndex);
+      if (conn.to.legoId === lego.instance_id) {
+        connectedLegs.add(conn.to.leg_index);
       }
     });
 
@@ -73,7 +73,7 @@ export const applyConnectGraphNodes = async (
       return Legos.createDynamicLego(
         "z_rep_code",
         lego.numberOfLegs + 1,
-        lego.instanceId,
+        lego.instance_id,
         lego.logicalPosition
       );
     }
@@ -87,7 +87,7 @@ export const applyConnectGraphNodes = async (
         {
           type_id: "h",
           name: "Hadamard",
-          shortName: "H",
+          short_name: "H",
           description: "Hadamard",
           parity_check_matrix: [
             [1, 0, 0, 1],
@@ -110,12 +110,12 @@ export const applyConnectGraphNodes = async (
     ({ lego, danglingLeg }, index) => {
       return [
         new Connection(
-          { legoId: connectorLego.instanceId, legIndex: index },
-          { legoId: hadamardLegos[index].instanceId, legIndex: 0 }
+          { legoId: connectorLego.instance_id, leg_index: index },
+          { legoId: hadamardLegos[index].instance_id, leg_index: 0 }
         ),
         new Connection(
-          { legoId: hadamardLegos[index].instanceId, legIndex: 1 },
-          { legoId: lego.instanceId, legIndex: danglingLeg }
+          { legoId: hadamardLegos[index].instance_id, leg_index: 1 },
+          { legoId: lego.instance_id, leg_index: danglingLeg }
         )
       ];
     }
@@ -124,7 +124,7 @@ export const applyConnectGraphNodes = async (
   // Update state
   const updatedLegos = [
     ...allLegos.filter(
-      (l) => !legos.some((selected) => selected.instanceId === l.instanceId)
+      (l) => !legos.some((selected) => selected.instance_id === l.instance_id)
     ),
     ...newLegos,
     connectorLego,
diff --git a/app/ui/src/transformations/FuseLegos.test.ts b/app/ui/src/transformations/FuseLegos.test.ts
index a09f894f..fe07e1ad 100644
--- a/app/ui/src/transformations/FuseLegos.test.ts
+++ b/app/ui/src/transformations/FuseLegos.test.ts
@@ -13,7 +13,7 @@ const testDroppedLegos = [
   new DroppedLego(
     {
       type_id: "lego1",
-      shortName: "L1",
+      short_name: "L1",
       name: "Lego 1",
       description: "Test Lego 1",
       parity_check_matrix: [[1, 0]],
@@ -26,7 +26,7 @@ const testDroppedLegos = [
   new DroppedLego(
     {
       type_id: "lego2",
-      shortName: "L2",
+      short_name: "L2",
       name: "Lego 2",
       description: "Test Lego 2",
       parity_check_matrix: [[1, 0]],
@@ -39,7 +39,7 @@ const testDroppedLegos = [
   new DroppedLego(
     {
       type_id: "stopper_x",
-      shortName: "X",
+      short_name: "X",
       name: "X-Phase Flip Stopper",
       description: "X-Phase Flip Stopper",
       parity_check_matrix: [[0, 1]],
@@ -55,7 +55,7 @@ const invalidDroppedLegos = [
   new DroppedLego(
     {
       type_id: "lego3",
-      shortName: "L3",
+      short_name: "L3",
       name: "Lego 3",
       description: "Test Lego 3",
       parity_check_matrix: [[1, 0]],
@@ -72,8 +72,8 @@ it("should successfully fuse two Z stopper legos into a single scalar one", asyn
   const fuseLegos = new FuseLegos(
     [
       new Connection(
-        { legoId: "instance1", legIndex: 0 },
-        { legoId: "instance2", legIndex: 0 }
+        { legoId: "instance1", leg_index: 0 },
+        { legoId: "instance2", leg_index: 0 }
       )
     ],
     testDroppedLegos,
@@ -85,7 +85,7 @@ it("should successfully fuse two Z stopper legos into a single scalar one", asyn
 
   expect(result.droppedLegos).toHaveLength(2);
   const fusedLego = result.droppedLegos.find(
-    (l) => l.instanceId === "newInstanceId"
+    (l) => l.instance_id === "newInstanceId"
   );
   expect(fusedLego).toBeTruthy();
   expect(fusedLego?.parity_check_matrix).toEqual([[1]]);
@@ -100,8 +100,8 @@ it("should successfully fuse an X and Z stopper legos into a single scalar one",
   const fuseLegos = new FuseLegos(
     [
       new Connection(
-        { legoId: "instance2", legIndex: 0 },
-        { legoId: "stopper3", legIndex: 0 }
+        { legoId: "instance2", leg_index: 0 },
+        { legoId: "stopper3", leg_index: 0 }
       )
     ],
     testDroppedLegos,
@@ -111,21 +111,9 @@ it("should successfully fuse an X and Z stopper legos into a single scalar one",
   );
   const result = await fuseLegos.apply(testDroppedLegos.slice(1, 3));
 
-  console.log(
-    "result",
-    result.droppedLegos.map((l) => {
-      return {
-        instanceId: l.instanceId,
-        parity_check_matrix: l.parity_check_matrix
-          .map((row) => row.join(" "))
-          .join("\n")
-      };
-    })
-  );
-
   expect(result.droppedLegos).toHaveLength(2);
   const fusedLego = result.droppedLegos.find(
-    (l) => l.instanceId === "newInstanceId"
+    (l) => l.instance_id === "newInstanceId"
   );
   expect(fusedLego).toBeTruthy();
 
@@ -152,7 +140,10 @@ it("should be able to fuse two independent legos with an external connection", a
   ];
   const fuseLegos = new FuseLegos(
     [
-      new Connection({ legoId: "5", legIndex: 0 }, { legoId: "6", legIndex: 0 })
+      new Connection(
+        { legoId: "5", leg_index: 0 },
+        { legoId: "6", leg_index: 0 }
+      )
     ],
     droppedLegos,
     () => {
@@ -163,7 +154,7 @@ it("should be able to fuse two independent legos with an external connection", a
 
   expect(result.droppedLegos).toHaveLength(2);
   const fusedLego = result.droppedLegos.find(
-    (l) => l.instanceId === "newInstanceId"
+    (l) => l.instance_id === "newInstanceId"
   );
   expect(fusedLego).toBeTruthy();
 });
@@ -180,7 +171,7 @@ it("should tensor the identity stopper with a regular lego", async () => {
   const result = await fuseLegos.apply(droppedLegos);
   expect(result.droppedLegos).toHaveLength(1);
   const fusedLego = result.droppedLegos.find(
-    (l) => l.instanceId === "newInstanceId"
+    (l) => l.instance_id === "newInstanceId"
   );
   expect(fusedLego).toBeTruthy();
   expect(fusedLego?.parity_check_matrix).toEqual([
@@ -195,7 +186,7 @@ it("should be able to fuse a scalar lego a stopper and a regular lego", async ()
     new DroppedLego(
       {
         type_id: "scalar",
-        shortName: "S",
+        short_name: "S",
         name: "Scalar",
         description: "Scalar",
         parity_check_matrix: [[1]],
@@ -213,7 +204,7 @@ it("should be able to fuse a scalar lego a stopper and a regular lego", async ()
   const result = await fuseLegos.apply(droppedLegos);
   expect(result.droppedLegos).toHaveLength(1);
   const fusedLego = result.droppedLegos.find(
-    (l) => l.instanceId === "newInstanceId"
+    (l) => l.instance_id === "newInstanceId"
   );
   expect(fusedLego).toBeTruthy();
   expect(fusedLego?.parity_check_matrix).toEqual([
diff --git a/app/ui/src/transformations/FuseLegos.ts b/app/ui/src/transformations/FuseLegos.ts
index 1cf0dc60..8dea3b15 100644
--- a/app/ui/src/transformations/FuseLegos.ts
+++ b/app/ui/src/transformations/FuseLegos.ts
@@ -2,7 +2,7 @@ import { Connection } from "../stores/connectionStore";
 import { Operation } from "../features/canvas/OperationHistory.ts";
 import { DroppedLego } from "../stores/droppedLegoStore.ts";
 import { TensorNetwork } from "../lib/TensorNetwork";
-import { recognize_parity_check_matrix } from "../features/lego/Legos.ts";
+import { recognize_parityCheckMatrix } from "../features/lego/Legos.ts";
 import { newInstanceId as storeNewInstanceId } from "../stores/droppedLegoStore";
 import { LogicalPoint } from "../types/coordinates.ts";
 
@@ -15,7 +15,6 @@ export class FuseLegos {
     private newInstanceId: ((legos: DroppedLego[]) => string) | null = null
   ) {
     if (this.newInstanceId === null) {
-      console.log("newInstanceId is null, using default");
       this.newInstanceId = storeNewInstanceId;
     }
   }
@@ -27,24 +26,26 @@ export class FuseLegos {
   }> {
     try {
       for (const lego of legosToFuse) {
-        if (!this.droppedLegos.some((l) => l.instanceId === lego.instanceId)) {
+        if (
+          !this.droppedLegos.some((l) => l.instance_id === lego.instance_id)
+        ) {
           throw new Error("Lego not found");
         }
       }
       // Get all connections between the legos being fused
       const internalConnections = this.connections.filter(
         (conn) =>
-          legosToFuse.some((l) => l.instanceId === conn.from.legoId) &&
-          legosToFuse.some((l) => l.instanceId === conn.to.legoId)
+          legosToFuse.some((l) => l.instance_id === conn.from.legoId) &&
+          legosToFuse.some((l) => l.instance_id === conn.to.legoId)
       );
 
       // Get all connections to legos outside the fusion group
       const externalConnections = this.connections.filter((conn) => {
         const fromInGroup = legosToFuse.some(
-          (l) => l.instanceId === conn.from.legoId
+          (l) => l.instance_id === conn.from.legoId
         );
         const toInGroup = legosToFuse.some(
-          (l) => l.instanceId === conn.to.legoId
+          (l) => l.instance_id === conn.to.legoId
         );
         return (fromInGroup && !toInGroup) || (!fromInGroup && toInGroup);
       });
@@ -56,20 +57,20 @@ export class FuseLegos {
       );
 
       // Create a map of old leg indices to track external connections
-      const legMap = new Map<string, { legoId: string; legIndex: number }>();
+      const legMap = new Map<string, { legoId: string; leg_index: number }>();
       externalConnections.forEach((conn) => {
         const isFromInGroup = legosToFuse.some(
-          (l) => l.instanceId === conn.from.legoId
+          (l) => l.instance_id === conn.from.legoId
         );
         if (isFromInGroup) {
-          legMap.set(`${conn.from.legoId}-${conn.from.legIndex}`, {
+          legMap.set(`${conn.from.legoId}-${conn.from.leg_index}`, {
             legoId: conn.to.legoId,
-            legIndex: conn.to.legIndex
+            leg_index: conn.to.leg_index
           });
         } else {
-          legMap.set(`${conn.to.legoId}-${conn.to.legIndex}`, {
+          legMap.set(`${conn.to.legoId}-${conn.to.leg_index}`, {
             legoId: conn.from.legoId,
-            legIndex: conn.from.legIndex
+            leg_index: conn.from.leg_index
           });
         }
       });
@@ -87,13 +88,13 @@ export class FuseLegos {
 
       // Try to recognize the type of the fused lego
       const recognized_type =
-        recognize_parity_check_matrix(result.h) || "fused_lego";
+        recognize_parityCheckMatrix(result.h) || "fused_lego";
 
       // Create a new lego with the calculated parity check matrix
       const newLego: DroppedLego = new DroppedLego(
         {
           type_id: recognized_type,
-          shortName: "Fused",
+          short_name: "Fused",
           name: "Fused Lego",
           description: "Fused " + legosToFuse.length + " legos",
           parity_check_matrix: result.h.getMatrix(),
@@ -112,29 +113,29 @@ export class FuseLegos {
       // Create new connections based on the leg mapping
       const newConnections = externalConnections.map((conn) => {
         const isFromInGroup = legosToFuse.some(
-          (l) => l.instanceId === conn.from.legoId
+          (l) => l.instance_id === conn.from.legoId
         );
         if (isFromInGroup) {
           // Find the new leg index from the legs array
           const newLegIndex = result.legs.findIndex(
             (leg) =>
-              leg.instanceId === conn.from.legoId &&
-              leg.legIndex === conn.from.legIndex
+              leg.instance_id === conn.from.legoId &&
+              leg.leg_index === conn.from.leg_index
           );
 
           return new Connection(
-            { legoId: newLego.instanceId, legIndex: newLegIndex },
+            { legoId: newLego.instance_id, leg_index: newLegIndex },
             conn.to
           );
         } else {
           const newLegIndex = result.legs.findIndex(
             (leg) =>
-              leg.instanceId === conn.to.legoId &&
-              leg.legIndex === conn.to.legIndex
+              leg.instance_id === conn.to.legoId &&
+              leg.leg_index === conn.to.leg_index
           );
           return new Connection(conn.from, {
-            legoId: newLego.instanceId,
-            legIndex: newLegIndex
+            legoId: newLego.instance_id,
+            leg_index: newLegIndex
           });
         }
       });
@@ -142,7 +143,7 @@ export class FuseLegos {
       // Update state
       const resultingDroppedLegos = [
         ...this.droppedLegos.filter(
-          (l) => !legosToFuse.some((fl) => fl.instanceId === l.instanceId)
+          (l) => !legosToFuse.some((fl) => fl.instance_id === l.instance_id)
         ),
         newLego
       ];
diff --git a/app/ui/src/transformations/Hopf.ts b/app/ui/src/transformations/Hopf.ts
index 6ec11b3e..545fb2c0 100644
--- a/app/ui/src/transformations/Hopf.ts
+++ b/app/ui/src/transformations/Hopf.ts
@@ -21,7 +21,8 @@ export function canDoHopfRule(
   // Count connections between the two legos
   const connectionsBetween = connections.filter(
     (conn) =>
-      conn.containsLego(lego1.instanceId) && conn.containsLego(lego2.instanceId)
+      conn.containsLego(lego1.instance_id) &&
+      conn.containsLego(lego2.instance_id)
   );
 
   // Must have more than one connection between them
@@ -46,19 +47,20 @@ export async function applyHopfRule(
   // Get all connections between the two legos
   const connectionsBetween = connections.filter(
     (conn) =>
-      conn.containsLego(xLego.instanceId) && conn.containsLego(zLego.instanceId)
+      conn.containsLego(xLego.instance_id) &&
+      conn.containsLego(zLego.instance_id)
   );
 
   // Get external connections for each lego
   const xExternalConns = connections.filter(
     (conn) =>
-      conn.containsLego(xLego.instanceId) &&
-      !conn.containsLego(zLego.instanceId)
+      conn.containsLego(xLego.instance_id) &&
+      !conn.containsLego(zLego.instance_id)
   );
   const zExternalConns = connections.filter(
     (conn) =>
-      conn.containsLego(zLego.instanceId) &&
-      !conn.containsLego(xLego.instanceId)
+      conn.containsLego(zLego.instance_id) &&
+      !conn.containsLego(xLego.instance_id)
   );
 
   // Calculate new number of legs for each lego (current - 2 for each pair removed)
@@ -68,7 +70,7 @@ export async function applyHopfRule(
 
   // Get the maximum instance ID from existing legos
   const maxInstanceId = Math.max(
-    ...droppedLegos.map((l) => parseInt(l.instanceId))
+    ...droppedLegos.map((l) => parseInt(l.instance_id))
   );
 
   // Create new legos with reduced legs
@@ -103,8 +105,9 @@ export async function applyHopfRule(
     if (
       !connectionsToRemove.some(
         (conn) =>
-          (conn.from.legoId === xLego.instanceId && conn.from.legIndex === i) ||
-          (conn.to.legoId === xLego.instanceId && conn.to.legIndex === i)
+          (conn.from.legoId === xLego.instance_id &&
+            conn.from.leg_index === i) ||
+          (conn.to.legoId === xLego.instance_id && conn.to.leg_index === i)
       )
     ) {
       xLegMapping.set(i, nextXLegIndex++);
@@ -115,8 +118,9 @@ export async function applyHopfRule(
     if (
       !connectionsToRemove.some(
         (conn) =>
-          (conn.from.legoId === zLego.instanceId && conn.from.legIndex === i) ||
-          (conn.to.legoId === zLego.instanceId && conn.to.legIndex === i)
+          (conn.from.legoId === zLego.instance_id &&
+            conn.from.leg_index === i) ||
+          (conn.to.legoId === zLego.instance_id && conn.to.leg_index === i)
       )
     ) {
       zLegMapping.set(i, nextZLegIndex++);
@@ -126,22 +130,22 @@ export async function applyHopfRule(
   // Recreate external connections for X lego
   xExternalConns.forEach((conn) => {
     const oldLegIndex =
-      conn.from.legoId === xLego.instanceId
-        ? conn.from.legIndex
-        : conn.to.legIndex;
+      conn.from.legoId === xLego.instance_id
+        ? conn.from.leg_index
+        : conn.to.leg_index;
     const externalEnd =
-      conn.from.legoId === xLego.instanceId ? conn.to : conn.from;
+      conn.from.legoId === xLego.instance_id ? conn.to : conn.from;
     const newLegIndex = xLegMapping.get(oldLegIndex);
 
     if (newLegIndex !== undefined) {
       newConnections.push(
         new Connection(
-          conn.from.legoId === xLego.instanceId
-            ? { legoId: newXLego.instanceId, legIndex: newLegIndex }
+          conn.from.legoId === xLego.instance_id
+            ? { legoId: newXLego.instance_id, leg_index: newLegIndex }
             : externalEnd,
-          conn.from.legoId === xLego.instanceId
+          conn.from.legoId === xLego.instance_id
             ? externalEnd
-            : { legoId: newXLego.instanceId, legIndex: newLegIndex }
+            : { legoId: newXLego.instance_id, leg_index: newLegIndex }
         )
       );
     }
@@ -150,22 +154,22 @@ export async function applyHopfRule(
   // Recreate external connections for Z lego
   zExternalConns.forEach((conn) => {
     const oldLegIndex =
-      conn.from.legoId === zLego.instanceId
-        ? conn.from.legIndex
-        : conn.to.legIndex;
+      conn.from.legoId === zLego.instance_id
+        ? conn.from.leg_index
+        : conn.to.leg_index;
     const externalEnd =
-      conn.from.legoId === zLego.instanceId ? conn.to : conn.from;
+      conn.from.legoId === zLego.instance_id ? conn.to : conn.from;
     const newLegIndex = zLegMapping.get(oldLegIndex);
 
     if (newLegIndex !== undefined) {
       newConnections.push(
         new Connection(
-          conn.from.legoId === zLego.instanceId
-            ? { legoId: newZLego.instanceId, legIndex: newLegIndex }
+          conn.from.legoId === zLego.instance_id
+            ? { legoId: newZLego.instance_id, leg_index: newLegIndex }
             : externalEnd,
-          conn.from.legoId === zLego.instanceId
+          conn.from.legoId === zLego.instance_id
             ? externalEnd
-            : { legoId: newZLego.instanceId, legIndex: newLegIndex }
+            : { legoId: newZLego.instance_id, leg_index: newLegIndex }
         )
       );
     }
@@ -174,21 +178,21 @@ export async function applyHopfRule(
   // Recreate remaining internal connections between the legos (if any)
   remainingConnections.forEach((conn) => {
     const oldXLegIndex =
-      conn.from.legoId === xLego.instanceId
-        ? conn.from.legIndex
-        : conn.to.legIndex;
+      conn.from.legoId === xLego.instance_id
+        ? conn.from.leg_index
+        : conn.to.leg_index;
     const oldZLegIndex =
-      conn.from.legoId === zLego.instanceId
-        ? conn.from.legIndex
-        : conn.to.legIndex;
+      conn.from.legoId === zLego.instance_id
+        ? conn.from.leg_index
+        : conn.to.leg_index;
     const newXLegIndex = xLegMapping.get(oldXLegIndex);
     const newZLegIndex = zLegMapping.get(oldZLegIndex);
 
     if (newXLegIndex !== undefined && newZLegIndex !== undefined) {
       newConnections.push(
         new Connection(
-          { legoId: newXLego.instanceId, legIndex: newXLegIndex },
-          { legoId: newZLego.instanceId, legIndex: newZLegIndex }
+          { legoId: newXLego.instance_id, leg_index: newXLegIndex },
+          { legoId: newZLego.instance_id, leg_index: newZLegIndex }
         )
       );
     }
@@ -197,14 +201,14 @@ export async function applyHopfRule(
   // Remove old legos and their connections
   const updatedDroppedLegos = droppedLegos
     .filter(
-      (lego) => !selectedLegos.some((l) => l.instanceId === lego.instanceId)
+      (lego) => !selectedLegos.some((l) => l.instance_id === lego.instance_id)
     )
     .concat(newLegos);
 
   const updatedConnections = connections
     .filter(
       (conn) =>
-        !selectedLegos.some((lego) => conn.containsLego(lego.instanceId))
+        !selectedLegos.some((lego) => conn.containsLego(lego.instance_id))
     )
     .concat(newConnections);
 
@@ -216,7 +220,7 @@ export async function applyHopfRule(
       data: {
         legosToRemove: selectedLegos,
         connectionsToRemove: connections.filter((conn) =>
-          selectedLegos.some((lego) => conn.containsLego(lego.instanceId))
+          selectedLegos.some((lego) => conn.containsLego(lego.instance_id))
         ),
         legosToAdd: newLegos,
         connectionsToAdd: newConnections
diff --git a/app/ui/src/transformations/InjectTwoLegged.ts b/app/ui/src/transformations/InjectTwoLegged.ts
index 172d97b3..0d3e1899 100644
--- a/app/ui/src/transformations/InjectTwoLegged.ts
+++ b/app/ui/src/transformations/InjectTwoLegged.ts
@@ -23,8 +23,11 @@ export class InjectTwoLegged {
 
     // Create new connections
     const newConnections = [
-      new Connection(connection.from, { legoId: lego.instanceId, legIndex: 0 }),
-      new Connection({ legoId: lego.instanceId, legIndex: 1 }, connection.to)
+      new Connection(connection.from, {
+        legoId: lego.instance_id,
+        leg_index: 0
+      }),
+      new Connection({ legoId: lego.instance_id, leg_index: 1 }, connection.to)
     ];
 
     const externalConnections = this.connections.filter(
@@ -41,7 +44,7 @@ export class InjectTwoLegged {
       // Update the position of the existing lego
       legosToAdd = [];
       updatedLegos = this.droppedLegos.map((l) => {
-        if (l.instanceId === lego.instanceId) {
+        if (l.instance_id === lego.instance_id) {
           legosToUpdate.push({
             oldLego: oldLego!,
             newLego: lego
diff --git a/app/ui/src/transformations/InverseBialgebra.ts b/app/ui/src/transformations/InverseBialgebra.ts
index 56f589da..26fff822 100644
--- a/app/ui/src/transformations/InverseBialgebra.ts
+++ b/app/ui/src/transformations/InverseBialgebra.ts
@@ -30,8 +30,8 @@ export function canDoInverseBialgebra(
     for (const xLego of xLegos) {
       const hasConnection = connections.some(
         (conn) =>
-          conn.containsLego(zLego.instanceId) &&
-          conn.containsLego(xLego.instanceId)
+          conn.containsLego(zLego.instance_id) &&
+          conn.containsLego(xLego.instance_id)
       );
       if (!hasConnection) return false;
     }
@@ -42,25 +42,25 @@ export function canDoInverseBialgebra(
     // Count external connections
     const externalConnections = connections.filter(
       (conn) =>
-        conn.containsLego(lego.instanceId) &&
+        conn.containsLego(lego.instance_id) &&
         !selectedLegos.some(
           (otherLego) =>
-            otherLego.instanceId !== lego.instanceId &&
-            conn.containsLego(otherLego.instanceId)
+            otherLego.instance_id !== lego.instance_id &&
+            conn.containsLego(otherLego.instance_id)
         )
     );
 
     // Count dangling legs
     const totalLegs = lego.numberOfLegs;
     const connectedLegs = connections
-      .filter((conn) => conn.containsLego(lego.instanceId))
+      .filter((conn) => conn.containsLego(lego.instance_id))
       .map((conn) =>
-        conn.from.legoId === lego.instanceId
-          ? conn.from.legIndex
-          : conn.to.legIndex
+        conn.from.legoId === lego.instance_id
+          ? conn.from.leg_index
+          : conn.to.leg_index
       );
     const danglingLegs = Array.from({ length: totalLegs }, (_, i) => i).filter(
-      (legIndex) => !connectedLegs.includes(legIndex)
+      (leg_index) => !connectedLegs.includes(leg_index)
     );
 
     // Check if there is exactly one external connection or dangling leg
@@ -86,19 +86,21 @@ export async function applyInverseBialgebra(
   // Get external connections for each partition
   const zExternalConns = connections.filter(
     (conn) =>
-      zLegos.some((lego) => conn.containsLego(lego.instanceId)) &&
+      zLegos.some((lego) => conn.containsLego(lego.instance_id)) &&
       !selectedLegos.some(
         (otherLego) =>
-          !zLegos.includes(otherLego) && conn.containsLego(otherLego.instanceId)
+          !zLegos.includes(otherLego) &&
+          conn.containsLego(otherLego.instance_id)
       )
   );
 
   const xExternalConns = connections.filter(
     (conn) =>
-      xLegos.some((lego) => conn.containsLego(lego.instanceId)) &&
+      xLegos.some((lego) => conn.containsLego(lego.instance_id)) &&
       !selectedLegos.some(
         (otherLego) =>
-          !xLegos.includes(otherLego) && conn.containsLego(otherLego.instanceId)
+          !xLegos.includes(otherLego) &&
+          conn.containsLego(otherLego.instance_id)
       )
   );
 
@@ -106,28 +108,28 @@ export async function applyInverseBialgebra(
   const zDanglingLegs = zLegos.flatMap((lego) => {
     const totalLegs = lego.numberOfLegs;
     const connectedLegs = connections
-      .filter((conn) => conn.containsLego(lego.instanceId))
+      .filter((conn) => conn.containsLego(lego.instance_id))
       .map((conn) =>
-        conn.from.legoId === lego.instanceId
-          ? conn.from.legIndex
-          : conn.to.legIndex
+        conn.from.legoId === lego.instance_id
+          ? conn.from.leg_index
+          : conn.to.leg_index
       );
     return Array.from({ length: totalLegs }, (_, i) => i)
-      .filter((legIndex) => !connectedLegs.includes(legIndex))
+      .filter((leg_index) => !connectedLegs.includes(leg_index))
       .map(() => true); // Convert to boolean array for counting
   });
 
   const xDanglingLegs = xLegos.flatMap((lego) => {
     const totalLegs = lego.numberOfLegs;
     const connectedLegs = connections
-      .filter((conn) => conn.containsLego(lego.instanceId))
+      .filter((conn) => conn.containsLego(lego.instance_id))
       .map((conn) =>
-        conn.from.legoId === lego.instanceId
-          ? conn.from.legIndex
-          : conn.to.legIndex
+        conn.from.legoId === lego.instance_id
+          ? conn.from.leg_index
+          : conn.to.leg_index
       );
     return Array.from({ length: totalLegs }, (_, i) => i)
-      .filter((legIndex) => !connectedLegs.includes(legIndex))
+      .filter((leg_index) => !connectedLegs.includes(leg_index))
       .map(() => true); // Convert to boolean array for counting
   });
 
@@ -138,7 +140,7 @@ export async function applyInverseBialgebra(
 
   // Get the maximum instance ID from existing legos
   const maxInstanceId = Math.max(
-    ...droppedLegos.map((l) => parseInt(l.instanceId))
+    ...droppedLegos.map((l) => parseInt(l.instance_id))
   );
 
   // Set positions and IDs
@@ -171,8 +173,8 @@ export async function applyInverseBialgebra(
   // Create connection between new legos (using their last legs)
   newConnections.push(
     new Connection(
-      { legoId: newZLego.instanceId, legIndex: zLegoLegs - 1 },
-      { legoId: newXLego.instanceId, legIndex: xLegoLegs - 1 }
+      { legoId: newZLego.instance_id, leg_index: zLegoLegs - 1 },
+      { legoId: newXLego.instance_id, leg_index: xLegoLegs - 1 }
     )
   );
 
@@ -180,13 +182,13 @@ export async function applyInverseBialgebra(
   zExternalConns.forEach((conn, index) => {
     // Find the external end that's not part of the Z partition
     const externalEnd = zLegos.some(
-      (lego) => lego.instanceId === conn.from.legoId
+      (lego) => lego.instance_id === conn.from.legoId
     )
       ? conn.to
       : conn.from;
     newConnections.push(
       new Connection(
-        { legoId: newZLego.instanceId, legIndex: index },
+        { legoId: newZLego.instance_id, leg_index: index },
         externalEnd
       )
     );
@@ -196,13 +198,13 @@ export async function applyInverseBialgebra(
   xExternalConns.forEach((conn, index) => {
     // Find the external end that's not part of the X partition
     const externalEnd = xLegos.some(
-      (lego) => lego.instanceId === conn.from.legoId
+      (lego) => lego.instance_id === conn.from.legoId
     )
       ? conn.to
       : conn.from;
     newConnections.push(
       new Connection(
-        { legoId: newXLego.instanceId, legIndex: index },
+        { legoId: newXLego.instance_id, leg_index: index },
         externalEnd
       )
     );
@@ -214,14 +216,14 @@ export async function applyInverseBialgebra(
   // Remove old legos and their connections
   const updatedDroppedLegos = droppedLegos
     .filter(
-      (lego) => !selectedLegos.some((l) => l.instanceId === lego.instanceId)
+      (lego) => !selectedLegos.some((l) => l.instance_id === lego.instance_id)
     )
     .concat(newLegos);
 
   const updatedConnections = connections
     .filter(
       (conn) =>
-        !selectedLegos.some((lego) => conn.containsLego(lego.instanceId))
+        !selectedLegos.some((lego) => conn.containsLego(lego.instance_id))
     )
     .concat(newConnections);
 
@@ -233,7 +235,7 @@ export async function applyInverseBialgebra(
       data: {
         legosToRemove: selectedLegos,
         connectionsToRemove: connections.filter((conn) =>
-          selectedLegos.some((lego) => conn.containsLego(lego.instanceId))
+          selectedLegos.some((lego) => conn.containsLego(lego.instance_id))
         ),
         legosToAdd: newLegos,
         connectionsToAdd: newConnections
diff --git a/app/ui/src/types/coordinates.ts b/app/ui/src/types/coordinates.ts
index e0cda0f3..59fc3cbb 100644
--- a/app/ui/src/types/coordinates.ts
+++ b/app/ui/src/types/coordinates.ts
@@ -125,88 +125,3 @@ export const isMiniCanvasPoint = (point: unknown): point is MiniCanvasPoint => {
     (point as MiniCanvasPoint).y <= 100
   );
 };
-
-// /**
-//  * Transform logical coordinates to canvas coordinates
-//  */
-// export const logicalToCanvas = (
-//   logicalPoint: LogicalPoint,
-//   zoomLevel: number,
-//   viewPortTopLeft: LogicalPoint
-// ): CanvasPoint => {
-//   return logicalPoint.minus(viewPortTopLeft).factor(zoomLevel);
-// };
-
-// /**
-//  * Transform canvas coordinates to logical coordinates
-//  */
-// export const canvasToLogical = (
-//   canvasPoint: CanvasPoint,
-//   zoomLevel: number,
-//   viewPortTopLeft: LogicalPoint
-// ): LogicalPoint => {
-//   return canvasPoint.factor(1 / zoomLevel).plus(viewPortTopLeft);
-// };
-
-// /**
-//  * Transform window coordinates to canvas coordinates
-//  */
-// export const windowToCanvasPoint = (
-//   windowPoint: WindowPoint,
-//   canvasRect: DOMRect
-// ): CanvasPoint => {
-//   return new CanvasPoint(
-//     windowPoint.x - canvasRect.left,
-//     windowPoint.y - canvasRect.top
-//   );
-// };
-
-// /**
-//  * Transform canvas coordinates to window coordinates
-//  */
-// export const canvasPointToWindow = (
-//   canvasHtmlPoint: CanvasPoint,
-//   canvasRect: DOMRect
-// ): WindowPoint => {
-//   return new WindowPoint(
-//     canvasHtmlPoint.x + canvasRect.left,
-//     canvasHtmlPoint.y + canvasRect.top
-//   );
-// };
-
-// /**
-//  * Convert mouse events to window coordinates
-//  */
-// export const mouseEventToWindowPoint = (
-//   e: MouseEvent | React.MouseEvent
-// ): WindowPoint => {
-//   return new WindowPoint(e.clientX, e.clientY);
-// };
-
-// /**
-//  * Convert mouse events to canvas coordinates
-//  */
-// export const mouseEventToCanvasPoint = (
-//   e: MouseEvent | React.MouseEvent,
-//   canvasRef: React.RefObject<HTMLDivElement | null>
-// ): CanvasPoint | null => {
-//   const rect = canvasRef.current?.getBoundingClientRect();
-//   if (!rect) return null;
-
-//   const windowPoint = mouseEventToWindowPoint(e);
-//   return windowToCanvasPoint(windowPoint, rect);
-// };
-
-// /**
-//  * Convert mouse events to logical coordinates
-//  */
-// export const mouseEventToLogicalPoint = (
-//   e: MouseEvent | React.MouseEvent,
-//   canvasRef: React.RefObject<HTMLDivElement | null> | null,
-//   zoomLevel: number,
-//   viewPortTopLeft: LogicalPoint
-// ): LogicalPoint | null => {
-//   const canvasPoint = mouseEventToCanvasPoint(e, canvasRef);
-//   if (!canvasPoint) return null;
-//   return canvasToLogical(canvasPoint, zoomLevel, viewPortTopLeft);
-// };
diff --git a/app/ui/tsconfig.json b/app/ui/tsconfig.json
index 195e164a..f96c2959 100644
--- a/app/ui/tsconfig.json
+++ b/app/ui/tsconfig.json
@@ -4,6 +4,7 @@
     "useDefineForClassFields": true,
     "lib": ["ES2020", "DOM", "DOM.Iterable"],
     "module": "ESNext",
+    "esModuleInterop": true,
     "skipLibCheck": true,
     "moduleResolution": "bundler",
     "allowImportingTsExtensions": true,
diff --git a/planqtn/codes/css_tanner_code.py b/planqtn/codes/css_tanner_code.py
index 50390290..0e0b3370 100644
--- a/planqtn/codes/css_tanner_code.py
+++ b/planqtn/codes/css_tanner_code.py
@@ -24,24 +24,24 @@ class CssTannerCodeTN(TensorNetwork):
             h0 = StabilizerCodeTensorEnumerator(
                 Legos.h,
                 idx=f"q{q}.h0",
-                annotation=LegoAnnotation(type="h", shortName=f"h0{q}"),
+                annotation=LegoAnnotation(type="h", short_name=f"h0{q}"),
             )
             h1 = StabilizerCodeTensorEnumerator(
                 Legos.h,
                 idx=f"q{q}.h1",
-                annotation=LegoAnnotation(type="h", shortName=f"h1{q}"),
+                annotation=LegoAnnotation(type="h", short_name=f"h1{q}"),
             )
 
             x = StabilizerCodeTensorEnumerator(
                 Legos.x_rep_code(2 + n_x_legs),
                 idx=f"q{q}.x",
-                annotation=LegoAnnotation(type="x_rep_code", shortName=f"x{q}"),
+                annotation=LegoAnnotation(type="x_rep_code", short_name=f"x{q}"),
             )
 
             z = StabilizerCodeTensorEnumerator(
                 Legos.x_rep_code(2 + n_z_legs),
                 idx=f"q{q}.z",
-                annotation=LegoAnnotation(type="x_rep_code", shortName=f"z{q}"),
+                annotation=LegoAnnotation(type="x_rep_code", short_name=f"z{q}"),
             )
 
             # leg numbering for the spiders: 0 for logical, 1 for physical,
@@ -51,7 +51,7 @@ class CssTannerCodeTN(TensorNetwork):
             i_stopper = StabilizerCodeTensorEnumerator(
                 Legos.stopper_i,
                 idx=f"q{q}.id",
-                annotation=LegoAnnotation(type="stopper_i", shortName=f"id{q}"),
+                annotation=LegoAnnotation(type="stopper_i", short_name=f"id{q}"),
             )
             q_tensors.append(i_stopper)
             q_tensors.append(h0)
@@ -101,7 +101,7 @@ class CssTannerCodeTN(TensorNetwork):
                 f"x{i}",
                 annotation=LegoAnnotation(
                     type="z_rep_code",
-                    shortName=f"x{i}",
+                    short_name=f"x{i}",
                 ),
             )
             # print(f"=== x tensor {g_tensor.idx} -> {qs} === ")
@@ -127,7 +127,7 @@ class CssTannerCodeTN(TensorNetwork):
                 f"z{i}",
                 annotation=LegoAnnotation(
                     type="z_rep_code",
-                    shortName=f"z{i}",
+                    short_name=f"z{i}",
                 ),
             )
             gz_tensors.append(g_tensor)
diff --git a/planqtn/legos.py b/planqtn/legos.py
index b79f26e5..1f781d91 100644
--- a/planqtn/legos.py
+++ b/planqtn/legos.py
@@ -27,7 +27,7 @@ class LegoAnnotation:
     y: Optional[float] = None
     description: Optional[str] = None
     name: Optional[str] = None
-    shortName: Optional[str] = None
+    short_name: Optional[str] = None
 
 
 class Legos:
@@ -135,7 +135,7 @@ class Legos:
             {
                 "id": LegoType.T6.value,
                 "name": "[[6,0,3]] tensor",
-                "shortName": "T6",
+                "short_name": "T6",
                 "description": "[[6,0,3]] encoding tensor",
                 "parity_check_matrix": cls.enconding_tensor_603.tolist(),
                 "logical_legs": [4, 5],
@@ -144,7 +144,7 @@ class Legos:
             {
                 "id": LegoType.T5.value,
                 "name": "[[5,1,2]] tensor",
-                "shortName": "T5",
+                "short_name": "T5",
                 "description": "[[5,1,2]] encoding tensor",
                 "parity_check_matrix": cls.enconding_tensor_512.tolist(),
                 "logical_legs": [4],
@@ -153,7 +153,7 @@ class Legos:
             {
                 "id": LegoType.H.value,
                 "name": "Hadamard",
-                "shortName": "H",
+                "short_name": "H",
                 "description": "Hadamard tensor",
                 "parity_check_matrix": cls.h.tolist(),
                 "logical_legs": [],
@@ -162,7 +162,7 @@ class Legos:
             {
                 "id": LegoType.STOPPER_X.value,
                 "name": "X Stopper",
-                "shortName": "X",
+                "short_name": "X",
                 "description": "X-type stopper tensor",
                 "parity_check_matrix": cls.stopper_x.tolist(),
                 "logical_legs": [],
@@ -171,7 +171,7 @@ class Legos:
             {
                 "id": LegoType.STOPPER_Z.value,
                 "name": "Z Stopper",
-                "shortName": "Z",
+                "short_name": "Z",
                 "description": "Z-type stopper tensor",
                 "parity_check_matrix": cls.stopper_z.tolist(),
                 "logical_legs": [],
@@ -180,7 +180,7 @@ class Legos:
             {
                 "id": LegoType.STOPPER_I.value,
                 "name": "Identity Stopper",
-                "shortName": "I",
+                "short_name": "I",
                 "description": "Identity stopper tensor",
                 "parity_check_matrix": cls.stopper_i.tolist(),
                 "logical_legs": [],
@@ -189,7 +189,7 @@ class Legos:
             {
                 "id": LegoType.ZREP.value,
                 "name": "Z-Repetition Code",
-                "shortName": "ZREP3",
+                "short_name": "ZREP3",
                 "description": "Bitflip code, ZZ stabilizers",
                 "is_dynamic": True,
                 "parameters": {"d": 3},
@@ -200,7 +200,7 @@ class Legos:
             {
                 "id": LegoType.XREP.value,
                 "name": "X-Repetition Code",
-                "shortName": "XREP3",
+                "short_name": "XREP3",
                 "description": "Phase flip code, XX stabilizers",
                 "is_dynamic": True,
                 "parameters": {"d": 3},
@@ -211,7 +211,7 @@ class Legos:
             {
                 "id": LegoType.ID.value,
                 "name": "Identity",
-                "shortName": "I",
+                "short_name": "I",
                 "description": "Identity tensor",
                 "parity_check_matrix": cls.identity.tolist(),
                 "logical_legs": [],
@@ -220,7 +220,7 @@ class Legos:
             {
                 "id": "steane",
                 "name": "Steane Code",
-                "shortName": "STN",
+                "short_name": "STN",
                 "description": "Steane code encoding tensor",
                 # fmt: off
                 "parity_check_matrix": cls.steane_code_813_encoding_tensor.tolist(),
@@ -231,7 +231,7 @@ class Legos:
             {
                 "id": "832",
                 "name": "[[8,3,2]] encoding tensor",
-                "shortName": "[[8,3,2]]",
+                "short_name": "[[8,3,2]]",
                 "description": "[[8,3,2]] encoding tensor with all 3 logical legs",
                 # fmt: off
                 "parity_check_matrix": np.array([
@@ -254,7 +254,7 @@ class Legos:
             {
                 "id": "15qrm",
                 "name": "[[15,1,3]] QRM encoding tensor",
-                "shortName": "QRM15",
+                "short_name": "QRM15",
                 "description": "[[15,1,3]] Quantum Reed-Muller code encoding tensor",
                 # fmt: off
                 "parity_check_matrix":  np.array([
diff --git a/pyproject.toml b/pyproject.toml
index dd302da5..c70b59b1 100644
--- a/pyproject.toml
+++ b/pyproject.toml
@@ -44,6 +44,7 @@ dev = [
     # Want to pin to avoid surprise pull request changes
     "black==25.1.0",
     "mypy==1.16.0",
+    "pydantic-to-typescript==2.0.0"
 ]
 
 [project.urls]
